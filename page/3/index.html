<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Destiny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Destiny">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Destiny">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Destiny">
  
    <link rel="alternate" href="/atom.xml" title="Destiny" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Destiny</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-YYModel源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/28/YYModel源码学习/" class="article-date">
  <time datetime="2018-04-28T02:15:28.000Z" itemprop="datePublished">2018-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/28/YYModel源码学习/">YYModel源码学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>项目里面居然还是手动解析服务端返回的json，简直不能忍受那些重复的代码。<br>现在市面OC上比较主流应该是MJExtension和YYModel了吧。（当然Swift应该是SwiftyJson，当前的工作栈主要是OC，就以YYModel入手了）</p>
<p>这是一个NSObject的Category,这也是YYModel的核心，因为它是通过runtime实现反射来实现的。<br>先看这个入口函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)yy_modelWithJSON:(id)json;</span><br><span class="line">+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json</span><br><span class="line">+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary;</span><br></pre></td></tr></table></figure>
<p>注意一下，这里传入的是一个id类型，参数名为json的对象。好吧，我就不卖关子了，json是有两种形态的，一个是json对象形态NSDictionary，另一种就是字符串形态NSString，除此以外这里也处理json字符串UTF8编码后的NSData。</p>
<p>所以第二个方法的工作就是将上述的所有的形态，转换成一个NSDictionary。也就是下面这个api的作用了。</p>
<p>然后就是根据NSDictionary生成Model了。</p>
<ol>
<li>根据惯例，首先是参数检查。</li>
<li>获得当前的Class</li>
<li>根据Class生成一个_YYModelMeta的对象，从名字看出他是这个类的元信息。</li>
<li>检查是否有自定义的Class去从字典转换</li>
<li>创建一个对象</li>
<li>给这个新的对象赋值，并返回</li>
</ol>
<p>首先来看这个_YYModelMeta对象吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)metaWithClass:(Class)cls;</span><br><span class="line">- (instancetype)initWithClass:(Class)cls;</span><br></pre></td></tr></table></figure></p>
<p>这里实用类方法，主要目的是增加一个缓存，提高效率。</p>
<ol>
<li>根据惯例，首先是参数检查。</li>
<li>使用单例，生成cache, lock。这个锁是基于信号量的。</li>
<li>加锁，从cache中寻找meta，解锁 （这一步提高性能）</li>
<li>如果没有找到meta,或者meta需要更新</li>
<li><p>生成meta,cache这个生成的meta，然后return</p>
<p> 生成meta的方法如下</p>
<ol>
<li><p>首先获得YYClassInfo, 没有则return nil<br> 这里还涉及一个YYClassInfo的创建,这里有三个容器，ivarInfos, methodInfos, propertyInfos，前两个感觉没啥用啊</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)classInfoWithClass:(Class)cls;</span><br><span class="line">- (instancetype)initWithClass:(Class)cls;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建classCache, metaCache, 锁</li>
<li>使用单例初始化</li>
<li>加锁，读cache</li>
<li>创建info, 设置cache<ol>
<li>参数检查</li>
<li>设置cls, superCls, 设置isMeta，不是meta获得metaCls, 获得类名</li>
<li>update，methodInfos, propertyInfos, ivarInfos</li>
<li>获得父类的ClassInfo</li>
</ol>
</li>
</ol>
</li>
<li>获取黑名单</li>
<li>获取白名单</li>
<li>获取容器中的类型，key比如得是属性名，value可以由Class或者是这个Class名字的字符串转成Class</li>
<li><p>建立一个属性的allPropertyMetas字典，遍历继承链，遍历propertyInfos，过滤 没有属性名，有黑名单并在名单中，有白名单不在名单中，生成属性meta, 过滤 属性meta不存在或者没有名字，meta没有getter或者setter，已存在（所以子类覆盖父类）。<br> 根据propertyInfo,生成_YYModelPropertyMeta</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)metaWithClassInfo:(YYClassInfo *)classInfo propertyInfo:(YYClassPropertyInfo *)propertyInfo generic:(Class)generic</span><br></pre></td></tr></table></figure>
</li>
<li><p>将结果存在_allPropertyMetas中可以为属性名，value 为propertyMeta</p>
</li>
<li>建立三个字典mapper，keyPathPropertyMetas，multiKeysPropertyMetas，主要处理keyPath的情况</li>
<li>判断是否有自定义Mapper,如果存在自定义customMapper,遍历<ol>
<li>从属性allPropertyMetas中找到PropertyMeta</li>
<li>将其从中移除</li>
<li>如果是字符串，判空，设置key, 判断是否是keypath,设置keyPath，设置_next, 设置mapper,key为keypath,value为propertyMeta</li>
<li>如果是数组，遍历，参数检查，判断到底是key还是keyPath, 设置mappedTokey属性，设置_next, 设置mapper</li>
</ol>
</li>
<li>设置mapper, keyPathPropertyMetas, multiKeysPropertyMetas</li>
<li>设置一系列属性</li>
</ol>
</li>
</ol>
<p>上部分主要是对这个类进行各种解析，接下去的我们就是创建一个对象，然后给这个对象赋值。<br>这里首先创建一个context，这个其中包含了modelMeta, model(创建出来的对象)，dictionary（一般是服务端返回）</p>
<p>这里根据_keyMappedCount和dic的数目对比，进行不同的处理，这里的遍历使用apply的方式。感觉是为了速度。</p>
<p>分不同的情况分别调用了，下面的两个方法  这里都是使用inline函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModelSetWithDictionaryFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModelSetWithPropertyMetaArrayFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>最后的最后都会走到这个方法上来，这个方法针对不同的value的可能性通过setter方法给其赋值。<br>如果是容器，会使用_genericCls的class,递归调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModelSetValueForProperty</span><span class="params">(__unsafe_unretained id model,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     __unsafe_unretained id value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     __unsafe_unretained _YYModelPropertyMeta *meta)</span></span></span><br></pre></td></tr></table></figure></p>
<p>最后一步就是自定义处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/28/YYModel源码学习/" data-id="ckg4jkczn000jpdj7er4klumn" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中的锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/26/iOS中的锁/" class="article-date">
  <time datetime="2018-04-26T12:11:20.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/26/iOS中的锁/">iOS中的锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先客观的来说平时的工作中对锁的理解并不是很深刻，只是在之前面试的时候简单了解过，锁的用处主要是保证线程安全，死锁的场景。</p>
<ol>
<li>初次接触的时候是在属性关键字中。nonatomic<br>系统会在setter和getter的方法中加锁。也就是说，如果操作值类型那么OK没问题，但是如果操作一个MutableArray,那么大多数情况不是去set或者get这个arra,而是去add或者remove这个容易，所以这个锁并没有左右。锁只是保证了这个指针变量本身，却不保证其指向的内容线程安全<br>。</li>
<li><p>后来在项目中看见有同学使用 @synchronized (self)的写法</p>
</li>
<li><p>后来也看见过NSLock</p>
</li>
<li><p>直到今天看SDWebImage的时候看到这个宏定义，我觉得不总结一下，说不过去了哈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNLOCK(lock) dispatch_semaphore_signal(lock);</span></span><br><span class="line"></span><br><span class="line">lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>atomic<br>dispatch_semaphore_t<br>pthread_mutex<br>pthread_mutex(recursive)<br>NSLock 是对pthread_mutex的封装，主要性能差别在用方法调用导致，其实并不大<br>NSCondition<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized 这个后面只需要传递一个OC对象，并把这个对象当成锁来使用，并不是锁住这个对象的意思（反正我之前是理解成锁住整个self了，手动滑稽）</p>
<p>什么是自旋锁？while忙等，注意优先级反转的问题（低优先级线程拿到锁，高优先级busy-wait消耗CPU时间，导致低优先级线程拿不到CPU时间，无法完成任务无法释放锁）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>; <span class="comment">// 一开始没有锁上，任何线程都可以申请锁  </span></span><br><span class="line"><span class="keyword">do</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span>(lock); <span class="comment">// 如果 lock 为 true 就一直死循环，相当于申请锁</span></span><br><span class="line">    lock = <span class="literal">true</span>; <span class="comment">// 挂上锁，这样别的线程就无法获得锁</span></span><br><span class="line">        Critical section  <span class="comment">// 临界区</span></span><br><span class="line">    lock = <span class="literal">false</span>; <span class="comment">// 相当于释放锁，这样别的线程可以进入临界区</span></span><br><span class="line">        Reminder section <span class="comment">// 不需要锁保护的代码        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么是互斥锁？pthread_mutex<br>PTHREAD_MUTEX_NORMAL<br>PTHREAD_MUTEX_ERRORCHECK==&gt;NSLock<br>PTHREAD_MUTEX_RECURSIVE==&gt;NSRecursiveLock</p>
<p>什么是递归锁？递归锁在被同一线程重复获取时不会产生死锁 NSRecursiveLock @synchronized<br>什么是信号量？<br>原理是首先将信号量减1，判断是否大于0，大于0则无需等待直接，反之则使线程进入休眠状态，让出时间片。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="keyword">sem_t</span> *sem)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> *futex = (<span class="keyword">int</span> *) sem;</span><br><span class="line">  <span class="keyword">if</span> (atomic_decrement_if_positive (futex) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> err = lll_futex_wait (futex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="死锁场景"><a href="#死锁场景" class="headerlink" title="死锁场景"></a>死锁场景</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@<span class="string">"1"</span>); <span class="comment">// 任务1</span></span><br><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"2"</span>); <span class="comment">// 任务2</span></span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@<span class="string">"3"</span>); <span class="comment">// 任务3</span></span><br></pre></td></tr></table></figure>
<ol>
<li>首先在主线程中 任务1毫无疑问肯定执行。</li>
<li>接着是一个同步函数，单线程中同步，将任务2添加到主队列的末尾。在主队列中 head-任务1-同步函数-任务3-任务2-tail。</li>
<li>任务3需要等待同步函数返回才会执行。任务2也得等待任务3执行完。相互等待死锁。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/26/iOS中的锁/" data-id="ckg4jkczy000npdj7exhginm7" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDWebImage源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/17/SDWebImage源码学习/" class="article-date">
  <time datetime="2018-04-17T09:34:22.000Z" itemprop="datePublished">2018-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/SDWebImage源码学习/">SDWebImage源码学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在刚刚接触iOS的时候就听说SDWebImage的大名，在第一家面试的时候也被问到过这个库的问题，后来或多或少的读过其源码。如今作为一个Developer已经三年了，来好好总结一下这个OCStar第二名。</p>
<p>首先在心中问一个问题，为什么要使用这个库？也许是因为他名气很大Star很多，也许是因为原来项目中就使用了这个库，也许是因为面试被虐知道了这个库。</p>
<p>他解决了什么问题？</p>
<ol>
<li>下载网络图片</li>
<li>Cell中复用问题</li>
<li>内存缓存和硬盘缓存</li>
<li>强制解码，增加渲染速度</li>
</ol>
<p>正常来说我们都是从UIImageView+WebCache.h这个文件开始的</p>
<p>这个Api是我个人使用最多的了。本质上都是调用下面这个api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder</span><br></pre></td></tr></table></figure></p>
<p>一层一层点进去，内部调用了UIView的一个Category的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context;</span><br></pre></td></tr></table></figure>
<p>先别晕，当一个框架暴露的接口越是简单，灵活，他的内部一定是复杂的。因为他帮你做了那些你该做的工作。这个方法是很长的，虽然这不符合我的50lines的规矩，但是规矩是人定的。</p>
<ol>
<li>第一步先取这个operationKey，正常我们使用的时候并不会设置这个，所以它默认应该是一个@”UIImageView”的字符串</li>
<li>cancel掉当前这个UIImageView上正在下载的图片，大概就是这个UIView lazy的方式关联一个NSMapTable(相当于是字典)，字典的key其实这就是类名，value为下载的operation，这个operation就是可以cancel的, cancel了之后再去下载下一张图片，也就不会出现一些复用导致的bug。（最经典的先下载的图片，因为网络后下载完成，覆盖上去导致错乱）</li>
<li>把图片的地址也关联到这个UIView上去</li>
<li>判断options中是否有延迟placeholder的设置项，没有的话就去设置placeholder，当然这其中有一个group 和 主线程的内容，先放一放</li>
<li>判断url url为空则移除indicator, 执行completedBlock抛出错误</li>
<li>url不为空，根据需要显示indicator。</li>
<li>重置图片下载进度</li>
<li>尝试从上下文中获取manager, 或者取单例的sharedManager</li>
<li>设置一个progress的block</li>
<li>manager根据url options等参数去下载图片，并返回一个operaion对象,将这个对象set到关联的NSMapTable中去。</li>
<li>这里的weak strong dance。首先检查sself，多线程的情况可能释放，移除indicator,设置progress的异常情况</li>
<li>根据options,不禁止自动设置图片，延迟设置placeholder，setNeedsLayout</li>
<li>设置image, 和 imageData</li>
<li>设置imageView的image,执行completedBlock</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock</span><br></pre></td></tr></table></figure>
<ol>
<li>检查是否completedBlock</li>
<li>检查URL的参数类型。NSString，NSURL</li>
<li>创建一个operation，设置他的manager为单例</li>
<li>看url 是否为失败的url</li>
<li>绝对url不存在，或者（是失败的url且不重试）, 调用完成，并返回operation</li>
<li>加锁并往runningOperations中增加一个operation</li>
<li>获取cacheKey</li>
<li>获取cacheOptions, 注意一下这里的位操作，学习了get</li>
<li><p>通过imageCache 获得一个cacheOperaion对象，</p>
<ol>
<li>cache完成之后的回调里，首先是weak strong dance</li>
<li>判空，或者已经取消的情况下从running中移除, return</li>
<li>根据options判断是否需要下载，else if有cacheImage的情况，else 没有cache并且被delegate cancel的情况</li>
<li>如果cache中找到了对应的图片，但是options中是refreshCache的设置，首先通知一下外部cacheType</li>
<li>设置downloadOperations</li>
<li><p>设置operation的downloadToken</p>
<ol>
<li>下载完成之后判空，判cancel</li>
<li>判断错误，记录错误</li>
<li>下载成功根据options 移除错误</li>
<li>根据options 是否保存到disk</li>
<li>scaledImageForKey</li>
<li>根据不同的case 去storeImage</li>
<li>移除operation</li>
</ol>
</li>
</ol>
</li>
<li><p>return这个operation</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br></pre></td></tr></table></figure>
<ol>
<li>判断key</li>
<li>从内存中寻找image</li>
<li>从disk中寻找diskData</li>
<li>从diskData–&gt;diskImage(创建，旋转，缩放，解码)</li>
<li>塞到内存缓存中去</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock</span><br></pre></td></tr></table></figure>
<ol>
<li>使用了一个weak</li>
<li>return DownloadToken<br>这是可以看到一个奇怪的方式，createCallback,创建request, 设置各种参数创建自定义的operation</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback</span><br></pre></td></tr></table></figure>
<ol>
<li>判断url</li>
<li>加锁，取出operation,如果没有就创建operation,设置一个完成的回调，将operation添加到queue中去，加入队列则开始下载了。</li>
<li>创建一个token,并返回</li>
</ol>
<p>此处，多线程的自定义operation操作很棒！值得深入学习！</p>
<p>这其中<br>SDWebImageDownloader ==== AFHTTPSessionManager<br>SDWebImageDownloaderOperation ===== AFURLSessionManagerTaskDelegate</p>
<p>其中AFNetworking中是维护了一个可变字典，SDWebImage中是遍历downQueue中的operation, 最终使用的都是dataTaskIdentifiter,直观感觉还是字典更快一些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/17/SDWebImage源码学习/" data-id="ckg4jkczk000hpdj79ifsz81k" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Autolayout学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/11/Autolayout学习笔记/" class="article-date">
  <time datetime="2018-03-11T06:48:11.000Z" itemprop="datePublished">2018-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/11/Autolayout学习笔记/">Autolayout学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先说一下我个人的观点，80%业务UI应该以IB的形式，15%应该用Masnory的方式，5%使用frame。IB发展到目前的阶段，我觉得已经不存在什么多人协作的问题了，性能我觉得也不是App的瓶颈所在。问题可能在于某一些动态创建不是很好处理，或者是大量创建重复元素的时候（是不是应该使用UITableView或者UICollectionView呢）。在某一些动画的场合可能还是frame要好一些。</p>
<ol>
<li><p>Using Code<br>我想现在主体还是使用这种方式的同学，应该已经很少了，这种方式缺点和优点同样明显。在适配方面简直不可原谅，也许有一些别的方法可以缓解（比如定义一个宏，方法根据屏幕比列去做缩放）但是在apple爸爸已经提供了Autolayout的基础上何必逆流呢？但是有一些动画场景，比如涉及到CALayer的地方，没办法🤷‍♀️只能是frame了</p>
</li>
<li><p>Using PureLayout &amp; Masonry/SnapKit<br>这是我接触iOS一来使用的最久的方式，也是目前市面上的主流吧。前一个框架可能使用者少一些，后一个从github的star排名来说绝对是火爆。作为之前的纯代码党的我来说，这套方案比什么VFL靠谱很多，至少不会因为一个typo满世界找原因，相比之前冗长的代码来说，简直就是福音。曾经的我以为只有代码敲出来的才是最好的，感觉自己控制了所有的细节。可是有一天我累了，每当写起大段的UI代码的时候，头都是很疼的，因为还需要起名字。</p>
</li>
<li><p>Using Interface Builder<br>这是我最近在使用的方式，其实很早之前我就了解过这个方式，不过由于之前的团队成员不太赞成，我也没有强行使用。首先我觉得要拥抱变化拥抱新事物，虽然有缺点，但都不是致命的，优点在于可视化，表现力强，就算是个外行也能看懂，UI站在你身后都能跟你聊两句~~（向做一点…向右一点…</p>
</li>
</ol>
<p>这里我还是主要说说2，3点吧<br>首先是Masonry<br>Masonry的代码写在哪里？文档说 mas_makeConstraints一系列方法写在updateConstraints这个方法中，但是要注意这个方法是会调用多次的，于是在Snapkit的demo中就会有一个标志位保证其只执行一次。而在Masonry的demo中View 都是现在init中，ViewController则是写在ViewDidLoad中。这点我个人也不是很确定，不过我现在是使用IB为主，我就不需要考虑写在哪里了✌️。</p>
<p>然后就是IB<br>并不是用了IB就可以随便写了，好的层次结构不管使用frame masonry 还是IB 写出来都是好维护的，相反层次混乱思路不清晰就是一团糟，需要足够理解设计者的意图才能写好UI。</p>
<p>-setNeedsUpdateConstraints<br>-setNeedsLayout<br>-setNeedsDisplay</p>
<p>核心方法1</p>
<ul>
<li>(void)updateConstraints<br>如果你需要在button点击之后调整constraint那么一定要立刻更改，为了保证在同一个runloop中。<br>这其中对应了三个,xxxIfNeeded,setNeedsxxx,xxxSomething。其实ifNeeded才会立刻执行，Needsxxx是会收集然后一起执行（waits for the next update cycle），xxxSomething一般都不会主动去调用，只是用来重载。<br>我在文档最后看到一个important的提示，[super updateConstraints]要放在最后</li>
</ul>
<p>核心方法2</p>
<ul>
<li>(void)layoutSubviews;<br>赶在视图绘制出来之前抓紧重写一下这个方法</li>
</ul>
<p>核心方法3</p>
<ul>
<li>(void)drawRect:(CGRect)rect;<br>一般不需要重写这个方法。</li>
</ul>
<ol>
<li>动态计算高度<br>在iOS中最多的地方其实就是Cell的自适应高度了，我来详细解释一下这个方式。<br>在iOS5以后的api中tableView多了一个UITableViewAutomaticDimension的常量，这个常量是-1。这个常量是rowHeight, estimatedRowHeight等一系列高度的默认值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line">@property (nonatomic) CGFloat rowHeight;             // default is UITableViewAutomaticDimension</span><br><span class="line">@property (nonatomic) CGFloat estimatedRowHeight     // default is UITableViewAutomaticDimension, set to 0 to disable</span><br></pre></td></tr></table></figure>
<p>当tableview 计算一个cell的高度的时候，首先回去检测是否实现了heightForRowAtIndexPath的方法，如果有则调用此方法<br>如果tableview没有实现heightForRowAtIndexPath的方法，就是rowHeight的作为高度。以上两种方式如果返回UITableViewAutomaticDimension，那么系统就会根据约束自己计算高度了。<br>estimatedRowHeight的设置要尽量接近真实的rowHeight, 不然主要是为了indicator会有跳动。</p>
<p>那么我们在设置UITableViewAutomaticDimension的时候我们该怎么去做，约束怎么写呢？<br>答案就是：用约束去撑开cell！！！<br>如果在console会有一些警告，并且你确定你的约束写的没有问题的话，你可以将其中的一个高度相关的约束优先级设置成999即可</p>
<ol>
<li><p>如何布局<br>首先我们要理解UIView 可以类比为前端的div，他们都是轻量级的而且没有明确意义的。也就是说用它们容器使得层次更加清晰。好的层次绝对比建立一两个UIView要来的划算，不过最要命的还是命名。。</p>
</li>
<li><p>关于动态生成<br>这里说的是在TableViewCell中，如果有的内容时有时无，并不能通过简单显示隐藏来解决的话，那就直接拖动生成就显得力不从心了。这里我目前使用纯代码写约束解决的。如果有更好的方式请告诉我。</p>
</li>
<li><p>关于scrollView的autolayout这个在面试的时候也是经常被问到<br>除了设置常规的edges之后还需要设置contentView的宽高，使用这么一个contentView来撑开这个scrollView</p>
</li>
<li><p>在使用xib的过程中是否遇到过只是添加一个占位的UIView。<br>但是不设置宽高会有红红的警告，设置了宽高的话又会有问题（因为毕竟不是真实需要的宽高，真实需要的是根据数据生成的）。这是xib的约束有个Placeholder remove at build time的设置可以勾上，完美！</p>
</li>
<li><p>在使用UILabel的过程中有没有使用两个UILabel，当文字超长的时候挤压哪一个？当文字都短的时候拉伸哪一个？</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;</span><br><span class="line">- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;</span><br></pre></td></tr></table></figure>
<p>对于UILabel来说HuggingPriority默认是251被拉伸的难易度，CompressionResistancePriority默认是750被压缩的难易度，数值越大代表越稳定越不容易变化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/11/Autolayout学习笔记/" data-id="ckg4jkcyf0001pdj787si2b8h" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CoreAnimation学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/CoreAnimation学习笔记/" class="article-date">
  <time datetime="2018-02-28T01:15:51.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/CoreAnimation学习笔记/">CoreAnimation学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>刚刚加入到一个新的团队，接到的第一个任务便是一个动画的需求，自然不能怠慢。之前的工作中对iOS的动画掌握仅仅限于UIView的Block动画，实在是惭愧，不如就这个机会好好研究一下这个CoreAnimation,于是才有这个笔记。搜索了一下资源，好评较高的是这个github的开源书籍<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="noopener">iOS-Core-Animation-Advanced-Techniques</a>。</p>
<p>首先来了解一下基础知识。CoreAnimation并不仅仅是动画，What? 我这么多年的英语白学了么，且往下看。</p>
<h2 id="UIView和CALayer"><a href="#UIView和CALayer" class="headerlink" title="UIView和CALayer"></a>UIView和CALayer</h2><p>UIView再熟悉不过啦，CALayer也许没那么熟，但是cornerRadius,borderWidth,borderColor等属性相比没有少用吧。看到CALayer这个名字，你应该会想到点什么对吧，没错前缀CA就是CoreAnimation的意思。那么下面是一道面试题，讲讲它们的关系。每一个UIView都有一个layer属性，这才是他显示的原因，CALayer并不知道响应链的存在，而且缺乏Autolayout的支持。但是为什么要分成两部分，主要是为了代码的复用，因为MacOS的显示也是CALayer, 但是鼠标、键盘的响应处理，却是截然不同的逻辑。UIView对CALayer进行了简单的封装，包含了大部分基础的属性。frame bounds center clipToBounds ==&gt; frame bounds position maskToBounds等等，但也不是全部，比如cornerRadius,shadowPath，还有一些别的没有暴露出来。学习CALayer是有必要的。一定程度上来说CALayer更轻量级，性能会有提高。（但是绝大部分还是UIView更合适，至少AutoLayout就已经让人无法拒绝了）</p>
<h2 id="CALayer的属性简单讲解"><a href="#CALayer的属性简单讲解" class="headerlink" title="CALayer的属性简单讲解"></a>CALayer的属性简单讲解</h2><ol>
<li>contents         id类型，但是只在iOS上只有传入一个CGImageRef类型的图片才会有显示</li>
<li>contentGravity   对应图片的显示模式，有点对应UIView的ContentMode</li>
<li>contentsScale    定义了寄宿图的像素尺寸和视图大小的比例</li>
<li>maskToBounds     对应于UIView的ClipToBounds</li>
<li>contentsRect     一般用于显示精灵图</li>
<li><p>contentsCenter   规定拉伸区域</p>
</li>
<li><p>frame            外部坐标, 是由bounds,position,transform计算而来的</p>
</li>
<li>bounds           内部坐标</li>
<li>position         锚点相对于父layer位置</li>
<li>transform</li>
<li>anchorPoint     默认位于layer的中心{0.5, 0.5}，相对坐标，可改变</li>
<li>zPosition       float控制上下顺序</li>
</ol>
<p>虽然CALayer不能处理事件，但是却提供了两个帮助处理的方法</p>
<ol>
<li>containsPoint</li>
<li><p>hitTest    </p>
</li>
<li><p>cornerRadius</p>
</li>
<li>borderWidth</li>
<li>borderColor</li>
<li>shadowColor,shadowOffset,shadowRadius</li>
<li>shadowPath</li>
<li>mask            mask不透明的地方就是保留下来的值</li>
<li>opacity         对应UIView的Alpha</li>
<li>shouldRasterize 栅格化</li>
</ol>
<h2 id="专有图层"><a href="#专有图层" class="headerlink" title="专有图层"></a>专有图层</h2><ol>
<li>CAShapeLayer</li>
<li>CATextLayer</li>
<li>CATransformLayer</li>
<li>CAGradientLayer</li>
<li>CAReplicatorLayer</li>
<li>CAScrollLayer</li>
<li>CATiledLayer</li>
<li>CAEmitterLayer</li>
<li>CAEAGLLayer</li>
<li>AVPlayerLayer</li>
</ol>
<h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>改变CALayer一个可做动画的属性时，属性会从先前的值平滑过渡到新的值，这一切都会默认行为。<br>CoreAnimation在每个runloop自动开始一次新的事务CATransaction。</p>
<p>CATransaction通过入栈出栈的方式工作，可以设置时间和完成后的任务。<br>begin<br>setAnimationDuration<br>setCompletionBlock<br>commit</p>
<p>隐身动画不能对UIView的关联图层起作用，那是如何禁用的呢？<br>-actionForKey: 主要是调用这个方法，以及内部的一系列方法。返回nil,则没有动画，返回CAAction协议对象，CALayer去做动画。<br>所以UIView其实就是layer的Delegate, 并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。</p>
<p>除此之外也可以通过setDisableActions，禁用隐式动画。</p>
<p>当设置属性的时候改变的是模型图层，动画中看到的是呈现图层。<br>presentationLayer<br>modelLayer</p>
<h2 id="显式动画"><a href="#显式动画" class="headerlink" title="显式动画"></a>显式动画</h2><p>能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。</p>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>CAAnimation –&gt; CAPropertyAnimation –&gt; CABasicAnimation</p>
<p>id fromValue<br>id toValue<br>id byValue</p>
<p>动画很常见的问题是，动画结束之后又立刻变回原始值。这是因为动画并没有改变图层模型。所以我们需要在动画开始之前或者之后改变属性的值。</p>
<p>动画之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)applyBasicAnimation:(CABasicAnimation *)animation toLayer:(CALayer *)layer</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //set the from value (using presentation layer if available)</span><br><span class="line">    animation.fromValue = [(layer.presentationLayer ? layer.presentationLayer : layer) valueForKeyPath:animation.keyPath];</span><br><span class="line">    //update the property in advance</span><br><span class="line">    //note: this approach will only work if toValue != nil </span><br><span class="line">    [CATransaction begin];</span><br><span class="line">    [CATransaction setDisableActions:YES];</span><br><span class="line">    [layer setValue:animation.toValue forKeyPath:animation.keyPath];</span><br><span class="line">    [CATransaction commit];</span><br><span class="line">    //apply animation to layer</span><br><span class="line">    [layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动画之后：</p>
<p>-animationDidStop:finished:</p>
<p>CAAnimation实现了KVC（键-值-编码）协议，于是你可以用-setValue:forKey:和-valueForKey:方法来存取属性。但是CAAnimation有一个与众不同的特性：它更像一个NSDictionary，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>
<h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p>CAAnimation –&gt; CAPropertyAnimation –&gt; CAKeyframeAnimation</p>
<p>values<br>path</p>
<h3 id="动画组"><a href="#动画组" class="headerlink" title="动画组"></a>动画组</h3><p>CAAnimationGroup</p>
<h2 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h2><p>CATransition</p>
<h2 id="动画的时间"><a href="#动画的时间" class="headerlink" title="动画的时间"></a>动画的时间</h2><p>duration 默认0.25<br>repeatCount 默认1<br>repeatDuration 它让动画重复一个指定的时间，而不是指定次数。<br>autoreverses</p>
<p>beginTime<br>speed<br>timeOffset</p>
<p>fillMode</p>
<h2 id="缓冲方程式"><a href="#缓冲方程式" class="headerlink" title="缓冲方程式"></a>缓冲方程式</h2><p>CAMediaTimingFunction timingFunctionWithName:   +functionWithControlPoints::::<br>timingFunctions 一个数组</p>
<p>当一个复杂的缓冲出现的时候，并不能使用一个3次贝塞尔曲线描述，可以使用</p>
<ol>
<li>用CAKeyframeAnimation创建一个动画，然后分割成几个步骤，每个小步骤使用自己的计时函数</li>
<li>使用定时器逐帧更新实现动画</li>
</ol>
<h2 id="CADisplayLink-NSTimer-NSRunloop"><a href="#CADisplayLink-NSTimer-NSRunloop" class="headerlink" title="CADisplayLink NSTimer NSRunloop"></a>CADisplayLink NSTimer NSRunloop</h2><h2 id="性能调优，CPU、GPU-高效绘图，图像IO-图层性能"><a href="#性能调优，CPU、GPU-高效绘图，图像IO-图层性能" class="headerlink" title="性能调优，CPU、GPU, 高效绘图，图像IO,图层性能"></a>性能调优，CPU、GPU, 高效绘图，图像IO,图层性能</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/CoreAnimation学习笔记/" data-id="ckg4jkcym0003pdj7rg04kn00" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AFNetworking学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/AFNetworking学习笔记/" class="article-date">
  <time datetime="2018-02-27T01:17:31.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/AFNetworking学习笔记/">AFNetworking学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是基于<a href="https://github.com/AFNetworking/AFNetworking/tree/3.2.0" target="_blank" rel="noopener">AFNetworking</a>v3.2.0</p>
<p>AFNetworking3.0以后去除了关于NSURLConnect的内容，都是基于NSURLSession去实现的，提供了AFURLSessionManager和AFHTTPSessionManager两个外部使用的Manager。提供了AFURLRequestSerialization和AFURLResponseSerialization，请求序列化和响应序列化的类。另外还有AFSecurityPolicy和AFNetworkReachabilityManager网络状态。</p>
<h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>首先从离我们最近的这个聊起吧。它继承自AFURLSessionManager。并且实现了两个协议&lt;NSSecureCoding, NSCopying&gt;。</p>
<h3 id="四个属性"><a href="#四个属性" class="headerlink" title="四个属性"></a>四个属性</h3><p>baseURL<br>requestSerializer<br>responseSerializer<br>securityPolicy</p>
<p>baseURL本身没有什么好说的<br>但是注意到为什么在h文件中<br>@property (readonly, nonatomic, strong, nullable) NSURL <em>baseURL;<br>在m文件中却又再写一次呢，居然不报错，为什么这么写呢，从修饰关键字可以看出，是为了对外只读，对内读写。怎么说呢，感觉比在很中间直接写一个get方法优雅一些，毕竟包含更多的信息量。<br>@property (readwrite, nonatomic, strong) NSURL </em>baseURL;</p>
<p>requestSerializer 默认为AFHTTPRequestSerializer</p>
<p>responseSerializer 默认为AFJSONResponseSerializer </p>
<p>@dynamic responseSerializer;<br>@dynamic securityPolicy;<br>这里稍微注意一下@dynamic关键字 参数responseSerializer的getter和setter方法并不在此处，而在其他地方实现了或者生成了，当你程序运行的时候你就知道了，所以别警告我了</p>
<h3 id="三个初始化方法"><a href="#三个初始化方法" class="headerlink" title="三个初始化方法"></a>三个初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)manager;</span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>前几个方法，最终都是调用了最后一个NS_DESIGNATED_INITIALIZER，关于designated_initializer在OC中不太常见，在Swift的文档中有详细的说明，我截取一部分</p>
<blockquote>
<p>Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</p>
<p>Classes tend to have very few designated initializers, and it is quite common for a class to have only one. Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</p>
<p>Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in Automatic Initializer Inheritance below.</p>
<p>Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</p>
<p>You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</p>
</blockquote>
<p>大意就是指定初始化方法是一个类的首要初始化方法，每个类至少有一个正常请求也只有一个，与之对应的便利初始化方法是次要初始化方法，可以有多个。指定初始化方法需要初始化类所有属性，并调用一个合理的父类的初始化方法去完成继承链上的初始化任务。便利初始化方法可以调用类的指定初始化方法，并把一些指定初始化方法的参数设置为默认。它是创建实例的一个快捷方式，使得初始化意图更清晰。</p>
<h3 id="一堆HTTP的方法"><a href="#一堆HTTP的方法" class="headerlink" title="一堆HTTP的方法"></a>一堆HTTP的方法</h3><p>GET, HEAD, POST, PUT, PATCH, DELETE方法<br>这里除了正确的使用对应的http方法之外。有一个tip，方法都返回了一个NSURLSessionDataTask对象。我觉得这个对象的主要作用在于管理已发出的请求，更具体一点，比如我在连续发送请求的时候可以取消上一次的请求，只发送本次请求。如何取消呢？就是task的cancel方法了。</p>
<p>这些方法中绝大部分最终都调用了dataTaskWithHTTPMethod方法。<br>此方法先是使用requestSerializer，创建出一个NSMutableURLRequest对象<br>通过dataTaskWithRequest创建dataTask对象，其中__block 修饰的dataTask对象<br>调用resume方法</p>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>session 被管理的NSURLSession对象<br>operationQueue Session发送请求所在的队列<br>securityPolicy 安全策略<br>reachabilityManager 网络监控器<br>responseSerializer 响应序列化器</p>
<p>tasks<br>dataTasks<br>uploadTasks<br>downloadTasks<br>这四个为计算属性，本身没什么好说的，但是看源码看到一个知识点。这是GCD中信号量的使用。<br>dispatch_semaphore_create 创建一个信号计数。<br>dispatch_semaphore_signal 发出一个信号使得计数+1。<br>dispatch_semaphore_wait 当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1。<br>下面的代码组合便可以等一个异步操作完成再执行之后代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p>completionQueue 完成队列，默认为主队列。<br>completionGroup 使用dispatch_group_async用来异步派发执行completionHandler回调是为了<br>留给调用者使用dispatch_group_notify等函数有机会监听completionHandler执行完成后的回调</p>
<p>attemptsToRecreateUploadTasksForBackgroundSessions, 如果创建uploadTask失败就重试3次</p>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul>
<li>(instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</li>
</ul>
<p>初始化 configuration，operationQueue, session, responseSerializer等一堆</p>
<p>其实每一个task对应一个AFURLSessionManagerTaskDelegate，用task的identifier作为key,将其存在一个NSMutableDictionary中。在这个Delegate中处理各自的请求</p>
<h3 id="主要是发送请求的一堆方法"><a href="#主要是发送请求的一堆方法" class="headerlink" title="主要是发送请求的一堆方法"></a>主要是发送请求的一堆方法</h3><p>dataTaskWithRequest<br>upload<br>download</p>
<p>设置各种block的</p>
<h2 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h2><p>用于验证HTTPS请求的证书，CA机构颁发证书比较昂贵，SSLPinningMode为证书绑定，是指客户端直接保存服务端的证书，建立https连接时直接对比服务端返回的和客户端保存的两个证书是否一样，一样就表明证书是真的，不再去系统的信任证书机构里寻找验证。</p>
<p><strong>公钥私钥加密，公钥加密私钥解密，私钥签名公钥验证。</strong></p>
<h3 id="四个属性-1"><a href="#四个属性-1" class="headerlink" title="四个属性"></a>四个属性</h3><p>SSLPinningMode，AFSSLPinningModeNone只在系统信任机构列表里验证服务端返回的证书。AFSSLPinningModeCertificate验证域名有效期，在验证公钥。AFSSLPinningModePublicKey验证公钥。<br>pinnedCertificates 附属的证书<br>allowInvalidCertificates 允许非权威机构颁发证书的 默认NO<br>validatesDomainName 验证域名 默认YES</p>
<h3 id="三个初始化方法-1"><a href="#三个初始化方法-1" class="headerlink" title="三个初始化方法"></a>三个初始化方法</h3><ul>
<li>(instancetype)defaultPolicy;</li>
<li>(instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode;</li>
<li>(instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet <nsdata *=""> *)pinnedCertificates;</nsdata></li>
</ul>
<h3 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h3><ul>
<li>(NSSet <nsdata *=""> <em>)certificatesInBundle:(NSBundle </em>)bundle;</nsdata></li>
</ul>
<ul>
<li>(BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(nullable NSString *)domain;</li>
</ul>
<p>这里主要来着最后一个方法，这个方法传入一个ServerTrust，和一个domain, 返回一个BOOL标识是否信任<br>首先是一个矛盾，也就是说校验自签名的域名必须使用pinning mode<br>如果需要验证域名，则增加一个域名SSL策略，不需要则加一个基础的BasicX509策略<br>SecTrustSetPolicies 为Trust设置策略<br>如果Mode为AFSSLPinningModeNone，允许不合法证书直接按返回YES, 在系统的信任机构列表中验证是否合法。<br>如果是Mode非NONE情况，不允许自签名证书，而又验证系统信任机构列表不通过的，直接返回NO;</p>
<p>AFSSLPinningModeCertificate<br>先验证证书是否ok，在验证本地证书是否一致</p>
<p>AFSSLPinningModePublicKey<br>验证公钥是否一致即可，不验证证书</p>
<h2 id="AFNetworkReachabilityManager"><a href="#AFNetworkReachabilityManager" class="headerlink" title="AFNetworkReachabilityManager"></a>AFNetworkReachabilityManager</h2><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>networkReachabilityStatus<br>reachable<br>reachableViaWWAN<br>reachableViaWiFi</p>
<p>这几个属性本质都是第一个属性的计算属性而已。</p>
<h3 id="初始化方法-1"><a href="#初始化方法-1" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul>
<li>(instancetype)sharedManager;</li>
<li>(instancetype)manager;</li>
<li>(instancetype)managerForDomain:(NSString *)domain;</li>
<li>(instancetype)managerForAddress:(const void *)address;</li>
</ul>
<ul>
<li>(instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;</li>
<li>(nullable instancetype)init NS_UNAVAILABLE;</li>
</ul>
<p>本质上都是获得一个reachability，内部持有（因为是corefoundation的内容所以手动管理内存），维护一个status的状态。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>(void)startMonitoring;</li>
<li>(void)stopMonitoring;</li>
<li>(NSString *)localizedNetworkReachabilityStatusString;</li>
<li>(void)setReachabilityStatusChangeBlock:(nullable void (^)(AFNetworkReachabilityStatus status))block;</li>
</ul>
<p>最终是调用SystemConfiguration中SCNetworkReachabilityScheduleWithRunLoop来完成监听。</p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>FOUNDATION_EXPORT NSString * const AFNetworkingReachabilityDidChangeNotification;</p>
<h2 id="AFURLRequestSerialization-协议"><a href="#AFURLRequestSerialization-协议" class="headerlink" title="AFURLRequestSerialization 协议"></a>AFURLRequestSerialization 协议</h2><h3 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h3><h3 id="AFPropertyListRequestSerializer"><a href="#AFPropertyListRequestSerializer" class="headerlink" title="AFPropertyListRequestSerializer"></a>AFPropertyListRequestSerializer</h3><p>正常情况下只是调用了这一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br></pre></td></tr></table></figure></p>
<p>第一步 参数检查，根据URLString生成request, 设置request对应的HTTPMethod<br>第二步 将不为空的属性值添加到request对象中去。<br>为了避免重复创建对象，使用一个静态数组保存需要KVO的KeyPath AFHTTPRequestSerializerObservedKeyPaths(), 在init中遍历添加观察者。<br>这里有一个小Tips就是添加KVO时候的context, 这个context用来判断相等。这里使用一个集合来存储值不为null的keypath, 为空则从集合中移除。<br>第三步 根据parameters继续生成request, 这里实现了这个协议的JSON或者Plist各自实现。这里我分析使用较多的JSON</p>
<h3 id="AFJSONRequestSerializer"><a href="#AFJSONRequestSerializer" class="headerlink" title="AFJSONRequestSerializer"></a>AFJSONRequestSerializer</h3><p>第四步 如何请求是GET HEAD DELETE 则是将参数拼接到URI后面的，调用父类的方法，设置header。这里setHeader和valueForHeader的读取都使用了多线程的技术。在一个并发队列中使用dispatch_barrier_async, dispatch_sync保证了读写的线程安全。<br>如果之前的request中没有这个header就设置这个默认的header。<br>如果存在自定义的请求参数序列化回调则使用自定义，不存在则使用默认的，将parameters拆成x=y&amp;q=e的形式拼接到URL之后。<br>第五步 如果请求是别的方法 则是校验Content-Type和params是否是json，转成data, 放置到HTTPBody中去。</p>
<h3 id="AFQueryStringPair"><a href="#AFQueryStringPair" class="headerlink" title="AFQueryStringPair"></a>AFQueryStringPair</h3><p>这个类用来实现url请求？后面的参数对类似”?pageNum=1&amp;pageSize=20”<br>AFPercentEscapedStringFromString方法的目的就是转义特殊字符</p>
<h2 id="AFURLResponseSerialization-协议"><a href="#AFURLResponseSerialization-协议" class="headerlink" title="AFURLResponseSerialization 协议"></a>AFURLResponseSerialization 协议</h2><p>正常情况下响应也是仅仅走这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br></pre></td></tr></table></figure></p>
<p>第一步 参数检查, 合法响应校验，检查类型，检查MIMEType，检查状态码100~200<br>第二步 判断响应data是不是空或者空格<br>第三步 解析json<br>第四步 根据参数是否移除json中的null，用一个递归来实现，其中NSJSONReadingMutableContainers 生成mutableArray 和 mutableDictionary</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/AFNetworking学习笔记/" data-id="ckg4jkd0y0010pdj7nu1uvg6y" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-类似股票数据表格效果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/27/类似股票数据表格效果/" class="article-date">
  <time datetime="2017-10-27T05:57:07.000Z" itemprop="datePublished">2017-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/27/类似股票数据表格效果/">类似股票数据表格效果</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="总结一下做一个备忘"><a href="#总结一下做一个备忘" class="headerlink" title="总结一下做一个备忘~~"></a>总结一下做一个备忘~~</h2><p>详细的需求参见同花顺等股票app，或者有技术统计的app。左侧一栏固定，右侧大量数据可以横划，上面header可悬浮，可上下拉刷新。</p>
<h2 id="一开始的思路"><a href="#一开始的思路" class="headerlink" title="一开始的思路"></a>一开始的思路</h2><p>我的第一感觉是左右侧有个tableview,右侧tableview放置在scrollview上可以完成横划效果。但是刷新不好处理，手势也较多。header悬浮也不好处理</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>考虑到header和刷新，我想是否可以通过一个tableView来实现？<br>顺着这个思路，那么每一行都是一个cell, 左侧可以是固定的label, 右侧则可以是一个collectionView。于是这里就有多个collectionView加在cell上的。<br>滚动了一个cell中的collectionview如何通知别的cell中呢？明显这是个1对多的问题，没错，就是通知。在didScroll中发通知是没错的。但是一旦滚动起来每个cell都在发通知肯定是不对的。所以最好是你滚动的那一个cell发通知，其他cell接受通知。这里我用一个flag属性来记录，我曾想过监听collectionview的contentOffset变化，然后发通知,但是效果不是很好，主要就是这个flag不好设置。最后我找到两个代理方法。<br><code>func scrollViewWillBeginDragging(_ scrollView: UIScrollView)</code>这个方法是手开始滑动触发<br><code>func scrollViewDidEndDecelerating(_ scrollView: UIScrollView)</code>这个方法是减速停止触发（因为手离开后，会有一个减速过程，contentoffset还是会变化）<br>我们真正关心的是我们滑动的那个cell中的collectionView的contentOffset的变化，不是吗?kvo无法判断是不是主动滑动的cell,会导致太多的cell在发通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private var flag = false</span><br><span class="line"></span><br><span class="line">override func awakeFromNib() &#123;</span><br><span class="line">    super.awakeFromNib()</span><br><span class="line">    NotificationCenter.default.addObserver(self, selector: #selector(offsetChange(_:)), name: NSNotification.Name.offsetChange, object: nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func offsetChange(_ notification: Notification)&#123;</span><br><span class="line">    if let object = notification.object as? CustomTableViewCell, object === self &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if let object = notification.object as? CustomHeaderView, object === self &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    collectionView.setContentOffset(notification.userInfo![&quot;offset&quot;] as! CGPoint, animated: false)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123;</span><br><span class="line">    self.flag = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123;</span><br><span class="line">    self.flag = false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func scrollViewDidScroll(_ scrollView: UIScrollView) &#123;</span><br><span class="line">    if self.flag &#123;</span><br><span class="line">        NotificationCenter.default.post(name: NSNotification.Name.offsetChange, object: self, userInfo: [&quot;offset&quot;: scrollView.contentOffset])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/27/类似股票数据表格效果/" data-id="ckg4jkd0c000wpdj7n4n02qrn" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OC之事件传递响应链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/12/OC之事件传递响应链/" class="article-date">
  <time datetime="2017-10-12T07:19:41.000Z" itemprop="datePublished">2017-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/12/OC之事件传递响应链/">OC之事件传递响应链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="hitTest"><a href="#hitTest" class="headerlink" title="hitTest"></a>hitTest</h2><p>这里yy了一下系统默认的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([self pointInside:point withEvent:event]) &#123; // 内部会调用pointInside方法</span><br><span class="line">        for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123;// 反向遍历，这样即使重叠也会优先处理，找到第一个hitTest的子视图，找不到就是自身</span><br><span class="line">            CGPoint convertedPoint = [subview convertPoint:point fromView:self];</span><br><span class="line">            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];</span><br><span class="line">            if (hitTestView) &#123;</span><br><span class="line">                return hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pointInside"><a href="#pointInside" class="headerlink" title="pointInside"></a>pointInside</h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li>扩大UIButton的点击区域</li>
<li>子view超出了父view的bounds响应事件（父view不去判断point inside直接遍历subView）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/12/OC之事件传递响应链/" data-id="ckg4jkczh000epdj7qbh3tp7f" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS之HTTP-HTTPS-TCP-UDP-DNS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/11/iOS之HTTP-HTTPS-TCP-UDP-DNS/" class="article-date">
  <time datetime="2017-10-11T09:01:10.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/11/iOS之HTTP-HTTPS-TCP-UDP-DNS/">iOS之HTTP,HTTPS,TCP,UDP,DNS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>get, post, head, put ,delete 等方法<br>request header<br>request body</p>
<p>response code<br>response header<br>response body</p>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>相对于http多了一个TLS加密层，目的是加密、完整性校验以及身份认证</p>
<p>大概过程如下</p>
<ol>
<li>客户端发起HTTPS请求</li>
<li>服务端的配置 （生成公钥私钥）</li>
<li>传送证书（证书相当于公钥）</li>
<li>客户端解析证书（共公钥加密一个随机数）</li>
<li>传送加密信息（发给服务端）</li>
<li>服务端解密信息（获得随机数）</li>
<li>传输加密后的信息（用这个随机数加密后传给客户端）</li>
<li>客户端解密信息</li>
</ol>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li>
</ol>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>无需建立连接（减少延迟</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名解析服务</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/11/iOS之HTTP-HTTPS-TCP-UDP-DNS/" data-id="ckg4jkczz000opdj7ey293wp4" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OC之属性关键字" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/29/OC之属性关键字/" class="article-date">
  <time datetime="2017-09-29T05:47:39.000Z" itemprop="datePublished">2017-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/29/OC之属性关键字/">OC之属性关键字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="assgin"><a href="#assgin" class="headerlink" title="assgin"></a>assgin</h2><p>assgin 用于纯量属性，不会增加引用计数。不要用来修饰对象，因为对象释放后，assgin修饰的变量不会置为nil，可能会导致野指针错误！</p>
<h2 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h2><p>用于对象不使retainCount增加，对象释放后会置为nil。</p>
<blockquote>
<p>runtime 对注册的类，会进行布局，对于weak对象会放入一个hash表中。用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，假如weak指向的对象内存地址是a，那么就会以a为键，在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。反之如果对象本身先释放，则将其从table中删除。</p>
</blockquote>
<h2 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h2><p>用于对象会使retainCount 增加</p>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>区别在set方法不用。<br>Block为什么用Copy</p>
<blockquote>
<p>Note: You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior. For more information, see Blocks Programming Topics.</p>
</blockquote>
<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>原子性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (UITextField *) userName &#123;</span><br><span class="line">    UITextField *retval = nil;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        retval = [[userName retain] autorelease];</span><br><span class="line">    &#125;</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setUserName:(UITextField *)userName_ &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">      [userName release];</span><br><span class="line">      userName = [userName_ retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h2><p>非原子性</p>
<h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><p>只读，不合成set方法</p>
<h2 id="nullable"><a href="#nullable" class="headerlink" title="nullable"></a>nullable</h2><p>可以为nil 对应Swift的optional</p>
<h2 id="nonnull"><a href="#nonnull" class="headerlink" title="nonnull"></a>nonnull</h2><p>不可以为nil 对应Swift的non optional</p>
<h2 id="ViewController的生命周期"><a href="#ViewController的生命周期" class="headerlink" title="ViewController的生命周期"></a>ViewController的生命周期</h2><p>First viewDidLoad       //1<br>First viewWillAppear    //2<br>First viewDidAppear     //3<br>—Click Push<br>First viewWillDisappear //4<br>Second viewDidLoad      //5<br>Second viewWillAppear   //6<br>—Push Finish<br>First viewDidDisappear  //7<br>Second viewDidAppear    //8<br>—Click Pop<br>Second viewWillDisappear//9<br>First viewWillAppear    //10<br>—Pop Finish<br>Second viewDidDisappear //11<br>First viewDidAppear     //12</p>
<h2 id="Autolayout的过程"><a href="#Autolayout的过程" class="headerlink" title="Autolayout的过程"></a>Autolayout的过程</h2><p>(setNeedUpdateConstraints,updateConstraintsIfNeeded)-&gt;updateConstraints<br>(setNeedsLayout,layoutIfNeeded)-&gt; layoutSubViews<br>-&gt; drawRect</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/29/OC之属性关键字/" data-id="ckg4jkczi000fpdj7u46fyhzm" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/音视频学习笔记/">音视频学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/20/常见iOSUI方案/">常见iOSUI方案</a>
          </li>
        
          <li>
            <a href="/2019/11/16/记一次MethodSwizzle的bugfix/">记一次MethodSwizzle的bugfix</a>
          </li>
        
          <li>
            <a href="/2019/10/27/MacBook-Pro-Retina-13-inch-Early-2015-更换ssd/">MacBook Pro(Retina, 13-inch, Early 2015)更换ssd</a>
          </li>
        
          <li>
            <a href="/2019/10/16/iOS证书和推送/">iOS证书和推送</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 hust_destiny<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>