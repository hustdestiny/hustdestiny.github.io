<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Destiny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Destiny">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Destiny">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Destiny">
  
    <link rel="alternate" href="/atom.xml" title="Destiny" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Destiny</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS逆向开发学习笔记（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/27/iOS逆向开发学习笔记（1）/" class="article-date">
  <time datetime="2018-08-27T09:07:35.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/27/iOS逆向开发学习笔记（1）/">iOS逆向开发学习笔记（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近进入到一个新的领域，iOS逆向。哇，听起来好像很高大上的样子呢。这个还是比较有门槛的，前期主要是要学习一些工具。</p>
<p>前提条件</p>
<ol>
<li>虚拟机+win7+爱思助手（越狱软件）</li>
<li>可越狱的iPhone设备</li>
<li>thoes框架（可以编写插件代码注入）</li>
<li>iFunBox (可以copy内容至指定Media文件夹)</li>
<li>Charles (网络工具)</li>
<li>Cycript/Reveal 主要用来看页面层级</li>
<li>老版本的Xcode7.1 执行 xcode-select -s app的路径</li>
<li>熟练使用linux/unix命令mv, cp, cat, grep, mkdir, rm 等, 使用vim, ssh</li>
</ol>
<p>安装<br>Cydia，越狱软件的AppStore。</p>
<ol>
<li>Filza</li>
<li>Substrate Safe Mode</li>
<li>Dropbear</li>
<li>Cycript</li>
<li>ssl-kill-switch2</li>
</ol>
<p>Thoes运行一个项目就可以跑起来了。</p>
<p>还没入门，任重道远。。fight!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/27/iOS逆向开发学习笔记（1）/" data-id="ckbnff0y0000qlwj79s3j6f8c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GPUImage学习笔记（4）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/27/GPUImage学习笔记（4）/" class="article-date">
  <time datetime="2018-07-27T13:21:35.000Z" itemprop="datePublished">2018-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/27/GPUImage学习笔记（4）/">GPUImage学习笔记（4）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GPUImage比我想象的要强大的多。我本想切换到Swift的版本。功力尚未达到，我又切回来了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/27/GPUImage学习笔记（4）/" data-id="ckbnff0xd0008lwj7vrlh3juu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GPUImage学习笔记（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/05/GPUImage学习笔记（3）/" class="article-date">
  <time datetime="2018-07-05T03:06:00.000Z" itemprop="datePublished">2018-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/05/GPUImage学习笔记（3）/">GPUImage学习笔记（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文记录一下探索GPUImage渲染的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">self.camera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPresetHigh cameraPosition:AVCaptureDevicePositionFront];</span><br><span class="line">self.camera.horizontallyMirrorFrontFacingCamera = YES;</span><br><span class="line">self.camera.outputImageOrientation = UIDeviceOrientationPortrait;</span><br><span class="line">self.filter = [[GPUImageFilter alloc] init];</span><br><span class="line">self.imageView = [[GPUImageView alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">[self.view addSubview:self.imageView];</span><br><span class="line"></span><br><span class="line">[self.camera addTarget:self.filter];</span><br><span class="line">[self.filter addTarget:self.imageView];</span><br><span class="line"></span><br><span class="line">[self.camera startCameraCapture];</span><br></pre></td></tr></table></figure>
<p>这是我在使用GPUImage的代码，很简单的完成了使用前置摄像头的任务，但是背后可不简单。</p>
<p>这里我设置了三个状态<br>position: AVCaptureDevicePositionFront  //这个状态使用了前置摄像头<br>horizontallyMirrorFrontFacingCamera: YES //前置摄像头镜像<br>outputImageOrientation: UIDeviceOrientationPortrait //输出的图像是竖方向的</p>
<p>videosettings:采样格式被设置为kCVPixelFormatType_420YpCbCr8BiPlanarFullRange===&gt;这种420f视频格式为NV12，Y分量一个plane,UV一起存储。Y1Y2…YN(U0V0)(U1V1)(Un/2Vn/2),UV前后顺序还得再确认下。</p>
<p>接着就是创建一个shader程序就其转换成RGBA的格式<br>vertex shader是最简单的直通<br>fragment shader就比较复杂了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">varying highp vec2 textureCoordinate;</span><br><span class="line"></span><br><span class="line">uniform sampler2D luminanceTexture;</span><br><span class="line">uniform sampler2D chrominanceTexture;</span><br><span class="line">uniform mediump mat3 colorConversionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mediump vec3 yuv;</span><br><span class="line">    lowp vec3 rgb;</span><br><span class="line">    </span><br><span class="line">    yuv.x = texture2D(luminanceTexture, textureCoordinate).r;</span><br><span class="line">    yuv.yz = texture2D(chrominanceTexture, textureCoordinate).ra - vec2(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    rgb = colorConversionMatrix * yuv;</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = vec4(rgb, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里除了传递了两个纹理之后，还传递了一个矩阵<br>GLfloat kColorConversion601FullRangeDefault[] = {<br>    1.0,    1.0,    1.0,<br>    0.0,    -0.343, 1.765,<br>    1.4,    -0.711, 0.0,<br>};<br>这个本质上是一个转换公式，将yuv420两个分量的纹理（y）(uv)转换成了rgba的纹理<br>1.0<em>y + 1.0</em>u + 1.0<em>v = r<br>0.0</em>y - 0.343<em>u + 1.765</em>v = g<br>1.4<em>y - 0.711</em>u + 0.0*v = b</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/05/GPUImage学习笔记（3）/" data-id="ckbnff0xb0007lwj7wjtk8d8y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GPUImage学习笔记（2）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/26/GPUImage学习笔记（2）/" class="article-date">
  <time datetime="2018-06-26T13:04:12.000Z" itemprop="datePublished">2018-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/26/GPUImage学习笔记（2）/">GPUImage学习笔记（2）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Source组件"><a href="#Source组件" class="headerlink" title="Source组件"></a>Source组件</h2><p>继承关系<br>GPUImageOutput –&gt; GPUImageVideoCamera –&gt; GPUImageStillCamera<br>               –&gt; GPUImagePicture<br>               –&gt; GPUImageMovie –&gt; GPUImageMovieComposition<br>               –&gt; GPUImageTextureInput<br>               –&gt; GPUImageRawDataInput<br>               –&gt; GPUImageUIElement</p>
<p>Source组件是数据的来源，依次为摄像头、图片、视频、opengl纹理、二进制数据、UIElement</p>
<h2 id="内置滤镜"><a href="#内置滤镜" class="headerlink" title="内置滤镜"></a>内置滤镜</h2><p>继承关系<br>GPUImageOutput –&gt; GPUImageFilter –&gt; GPUImageTwoInputFilter –&gt; GPUImageThreeInputFilter –&gt; GPUImageFourInputFilter<br>                                                             –&gt; GPUImageTwoInputCrossTextureSamplingFilter<br>               –&gt; GPUImageTwoPassFilter –&gt; GPUImageTwoPassTextureSamplingFilter<br>               –&gt; GPUImageFilterGroup<br>               –&gt; GPUImage3x3TextureSamplingFilter</p>
<p>内置滤镜</p>
<ol>
<li>颜色处理</li>
<li>图像处理</li>
<li>混合</li>
<li>效果</li>
</ol>
<p>这是滤镜的抽象基类，绝大部分滤镜都可以从这里继承，然后写对应的shader程序</p>
<h2 id="Output组件"><a href="#Output组件" class="headerlink" title="Output组件"></a>Output组件</h2><p>GPUImageView<gpuimageinput><br>GPUImageMovieWriter<gpuimageinput><br>GPUImageTextureOutput<gpuimageinput><br>GPUImageRawDataOutput<gpuimageinput></gpuimageinput></gpuimageinput></gpuimageinput></gpuimageinput></p>
<p>这是终点，他们都遵循了<gpuimageinput>协议</gpuimageinput></p>
<h2 id="GLProgram-（创建-编译-链接-使用）"><a href="#GLProgram-（创建-编译-链接-使用）" class="headerlink" title="GLProgram （创建 编译 链接 使用）"></a>GLProgram （创建 编译 链接 使用）</h2><ol>
<li>创建一个着色器程序，编译顶点和片段着色器，attach到program中去</li>
<li>链接着色器程序，链接成功后删除顶点和片段着色器，初始化完成</li>
<li>使用着色器程序，也包括设置和获得attribute和uniform</li>
</ol>
<h2 id="GPUImageContext"><a href="#GPUImageContext" class="headerlink" title="GPUImageContext"></a>GPUImageContext</h2><ol>
<li>初始化绘制串行队列</li>
<li>当前着色器程序</li>
<li>初始化OpenGLES上下文</li>
<li>初始化CoreVideo纹理缓存， CVOpenGLESTextureCacheCreateTextureFromImage的作用是将CVPixelBufferRef转换成texture，其中使用到texturecache需要提前创建好。CVOpenGLESTextureCacheCreate。</li>
<li>初始化framebuffercache</li>
<li>提供一个获取program的方法，方法中还缓存program</li>
</ol>
<h2 id="GPUImageFramebuffer"><a href="#GPUImageFramebuffer" class="headerlink" title="GPUImageFramebuffer"></a>GPUImageFramebuffer</h2><ol>
<li>初始化方法,其主要的目的是生成framebuffer和一个绑定的空texture。</li>
<li>generateFramebuffer，生成framebuffer,与opengl绑定。根据选项生成纹理，与opengl绑定。分配纹理的空间。将其作为framebuffer的附件。</li>
<li>纹理的生成CVOpenGLESTextureCacheCreateTextureFromImage效率更高。renderTarget是一个空的CVPixelBufferRef<br>(CVPixelBufferRef+CVOpenGLESTextureCacheRef)=&gt;CVOpenGLESTextureRef=&gt;texture</li>
</ol>
<h2 id="GPUImageFramebufferCache-管理Framebuffer"><a href="#GPUImageFramebufferCache-管理Framebuffer" class="headerlink" title="GPUImageFramebufferCache 管理Framebuffer"></a>GPUImageFramebufferCache 管理Framebuffer</h2><h2 id="shader程序"><a href="#shader程序" class="headerlink" title="shader程序"></a>shader程序</h2><p>varying highp vec2 textureCoordinate;</p>
<p>varying 是顶点着色器和片段着色器之间做数据传递使用，一般来说是，顶点着色器修改varying变量值，片段着色器使用这个值。<br>highp 声明了变量的精度（另外还有mediump, lowp）<br>vec2 声明了变量的类型是一个二维变量<br>textureCoordinate 这个变量名是纹理坐标的意思。因为需要在顶点和片段着色器中同时使用，所以是不能更改的。可以理解为当前坐标</p>
<p>uniform sampler2D inputImageTexture;<br>uniform 表示变量是外部传递进来的shader变量，只能使用不能修改<br>sampler2D 表示是一个2D纹理<br>inputImageTexture 这个变量名表示输入的图像。可以理解为当前图像</p>
<p>uniform mediump vec3 inputColor;<br>uniform mediump float threshold;<br>这两个是外部传进来的变量,在GPUImage中通过如下代码可以设置传入<br>[positionFilter setFloat:thresholdSensitivity forUniformName:@”threshold”];<br>[positionFilter setFloatVec3:thresholdColor forUniformName:@”inputColor”];</p>
<p>const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);//权重<br>vec4 pixelColor = texture2D(inputImageTexture, textureCoordinate);//取出像素点<br>lowp float luminance = dot(pixelColor.rgb, luminanceWeighting);//点乘，计算中和亮度值<br>lowp vec3 greyScaleColor = vec3(luminance)<br>gl_FragColor 是 Fragment Shader 预先定义的变量，赋给它的值就是该片段最终的颜色值</p>
<h2 id="基本的shader函数"><a href="#基本的shader函数" class="headerlink" title="基本的shader函数"></a>基本的shader函数</h2><p>mix 线性差值函数<br>函数接口mix(x, y, level);<br>x, y : 输入值<br>level :  插值系数<br>return : 返回插值结果<br>描述 : dest = x <em> (1 - level) + y </em> level;</p>
<p>clamp 规整输入值<br>函数接口: clamp(x, min, max)<br>x : 输入值<br>min : 最小值<br>max : 最大值<br>return : 根据输入的x，返回介于 min 与 max 之间的值。<br>描述 : 当 x &lt; min时，返回min，当 x &gt; max 时，返回 max</p>
<p>dot 点乘<br>函数接口: dot(x, y)<br>x, y : 输入变量，必须是向量<br>return : 点积结果<br>描述 : 对于向量a, b，返回的结果是 y = ∑(ai * bi) 乘积之和。</p>
<h3 id="Vertex-shader"><a href="#Vertex-shader" class="headerlink" title="Vertex shader"></a>Vertex shader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 position;//顶点坐标</span><br><span class="line">attribute vec4 inputTextureCoordinate;//传入纹理坐标</span><br><span class="line"></span><br><span class="line">varying vec2 textureCoordinate;//传给frag的坐标</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = position;//预定义变量</span><br><span class="line">    textureCoordinate = inputTextureCoordinate.xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 顶点坐标 position 原点在中间<br>        // 屏幕四个顶点<br>        static const GLfloat imageVertices[] = {<br>            -1.0f, -1.0f,<br>            1.0f, -1.0f,<br>            -1.0f,  1.0f,<br>            1.0f,  1.0f,<br>        };<br> 纹理坐标 inputTextureCoordinate 左下角是原点，从左到右、从下到上坐标依次递增。<a href="https://www.jianshu.com/p/e7245b62d2b3" target="_blank" rel="noopener">坐标解释</a></p>
<h3 id="fragmentShader"><a href="#fragmentShader" class="headerlink" title="fragmentShader"></a>fragmentShader</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> varying highp vec2 textureCoordinate;</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)renderToTextureWithVertices:(const GLfloat *)vertices textureCoordinates:(const GLfloat *)textureCoordinates</span><br><span class="line"> 上面这个是GPUImageFilter的默认方法，大致做了这么几件事情：</span><br><span class="line">1). 向frameBufferCache申请一个outputFrameBuffer</span><br><span class="line">2). 将申请得到的outputFrameBuffer激活并设为渲染对象</span><br><span class="line">3). glClear清除画布</span><br><span class="line">4). 设置输入纹理</span><br><span class="line">5). 传入顶点</span><br><span class="line">6). 传入纹理坐标</span><br><span class="line">7). 调用绘制方法</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageBrightnessFilter-明亮滤镜"><a href="#GPUImageBrightnessFilter-明亮滤镜" class="headerlink" title="GPUImageBrightnessFilter 明亮滤镜"></a>GPUImageBrightnessFilter 明亮滤镜</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">varying highp vec2 textureCoordinate; //纹理坐标，可以理解为当前处理像素点的坐标</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture; // 输入图像的纹理，可以理解为需要处理的图像</span><br><span class="line">uniform lowp float brightness; // 明亮度，-1到1的一个值。</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);//取出输入图像对应坐标 的纹理color</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = vec4((textureColor.rgb + vec3(brightness)), textureColor.w);//将像素的rgb值，同时加上明亮值，保持原来的w值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageLevelsFilter-色阶滤镜"><a href="#GPUImageLevelsFilter-色阶滤镜" class="headerlink" title="GPUImageLevelsFilter 色阶滤镜"></a>GPUImageLevelsFilter 色阶滤镜</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define GammaCorrection(color, gamma)								pow(color, 1.0 / gamma)</span><br><span class="line">#define LevelsControlInputRange(color, minInput, maxInput)				min(max(color - minInput, vec3(0.0)) / (maxInput - minInput), vec3(1.0))</span><br><span class="line">#define LevelsControlInput(color, minInput, gamma, maxInput)				GammaCorrection(LevelsControlInputRange(color, minInput, maxInput), gamma)</span><br><span class="line">#define LevelsControlOutputRange(color, minOutput, maxOutput) 			mix(minOutput, maxOutput, color)</span><br><span class="line">#define LevelsControl(color, minInput, gamma, maxInput, minOutput, maxOutput) 	LevelsControlOutputRange(LevelsControlInput(color, minInput, gamma, maxInput), minOutput, maxOutput)</span><br><span class="line"></span><br><span class="line">NSString *const kGPUImageLevelsFragmentShaderString = SHADER_STRING</span><br><span class="line">(</span><br><span class="line"> varying highp vec2 textureCoordinate;</span><br><span class="line"> </span><br><span class="line"> uniform sampler2D inputImageTexture;</span><br><span class="line"> uniform mediump vec3 levelMinimum;</span><br><span class="line"> uniform mediump vec3 levelMiddle;</span><br><span class="line"> uniform mediump vec3 levelMaximum;</span><br><span class="line"> uniform mediump vec3 minOutput;</span><br><span class="line"> uniform mediump vec3 maxOutput;</span><br><span class="line"> </span><br><span class="line"> void main()</span><br><span class="line"> &#123;</span><br><span class="line">     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">     </span><br><span class="line">     gl_FragColor = vec4(LevelsControl(textureColor.rgb, levelMinimum, levelMiddle, levelMaximum, minOutput, maxOutput), textureColor.a);</span><br><span class="line"> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageExposureFilter-曝光度"><a href="#GPUImageExposureFilter-曝光度" class="headerlink" title="GPUImageExposureFilter 曝光度"></a>GPUImageExposureFilter 曝光度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">varying highp vec2 textureCoordinate;</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">uniform highp float exposure;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = vec4(textureColor.rgb * pow(2.0, exposure), textureColor.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageContrastFilter-对比度"><a href="#GPUImageContrastFilter-对比度" class="headerlink" title="GPUImageContrastFilter 对比度"></a>GPUImageContrastFilter 对比度</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> varying highp vec2 textureCoordinate;</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">uniform lowp float contrast;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = vec4(((textureColor.rgb - vec3(0.5)) * contrast + vec3(0.5)), textureColor.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageSaturationFilter-饱和度"><a href="#GPUImageSaturationFilter-饱和度" class="headerlink" title="GPUImageSaturationFilter 饱和度"></a>GPUImageSaturationFilter 饱和度</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  varying highp vec2 textureCoordinate;</span><br><span class="line"> </span><br><span class="line"> uniform sampler2D inputImageTexture;</span><br><span class="line"> uniform lowp float saturation;</span><br><span class="line"> </span><br><span class="line"> // Values from &quot;Graphics Shaders: Theory and Practice&quot; by Bailey and Cunningham</span><br><span class="line"> const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);</span><br><span class="line"> </span><br><span class="line"> void main()</span><br><span class="line"> &#123;</span><br><span class="line">    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">    lowp float luminance = dot(textureColor.rgb, luminanceWeighting);</span><br><span class="line">    lowp vec3 greyScaleColor = vec3(luminance);</span><br><span class="line">    </span><br><span class="line">	gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w);</span><br><span class="line">	 </span><br><span class="line"> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageGammaFilter-伽马滤镜"><a href="#GPUImageGammaFilter-伽马滤镜" class="headerlink" title="GPUImageGammaFilter 伽马滤镜"></a>GPUImageGammaFilter 伽马滤镜</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">varying highp vec2 textureCoordinate;</span><br><span class="line"></span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">uniform lowp float gamma;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</span><br><span class="line">    </span><br><span class="line">    gl_FragColor = vec4(pow(textureColor.rgb, vec3(gamma)), textureColor.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GPUImageLookupFilter-查找表滤波"><a href="#GPUImageLookupFilter-查找表滤波" class="headerlink" title="GPUImageLookupFilter 查找表滤波"></a>GPUImageLookupFilter 查找表滤波</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> NSString *const kGPUImageLookupFragmentShaderString = SHADER_STRING</span><br><span class="line">(</span><br><span class="line"> varying highp vec2 textureCoordinate;  // src图片的像素坐标</span><br><span class="line"> varying highp vec2 textureCoordinate2; // lookup图片的像素坐标，未使用</span><br><span class="line"> </span><br><span class="line"> uniform sampler2D inputImageTexture;   // src图片的纹理信息，相当于图片信息的二维矩阵</span><br><span class="line"> uniform sampler2D inputImageTexture2; // lookup texture</span><br><span class="line"> </span><br><span class="line"> uniform lowp float intensity; // 强度</span><br><span class="line"></span><br><span class="line"> void main()</span><br><span class="line"> &#123;</span><br><span class="line">     highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);//根据图片矩阵和坐标，取出一个点的（r,g,b,a）,这里都是归一化的</span><br><span class="line">     </span><br><span class="line">     highp float blueColor = textureColor.b * 63.0;//首先根据b，计算一个（0~63）的值，假设为1.0</span><br><span class="line">     </span><br><span class="line">     highp vec2 quad1;//定义一个二维向量，代码坐标</span><br><span class="line">     quad1.y = floor(floor(blueColor) / 8.0);//floor返回小于或等于指定表达式的最大整数，==&gt;7.0</span><br><span class="line">     quad1.x = floor(blueColor) - (quad1.y * 8.0); //===&gt; 7.0</span><br><span class="line">     </span><br><span class="line">     highp vec2 quad2;</span><br><span class="line">     quad2.y = floor(ceil(blueColor) / 8.0);// ceil返回大于或者等于指定表达式的最小整数 ==&gt;7.0</span><br><span class="line">     quad2.x = ceil(blueColor) - (quad2.y * 8.0);//==&gt; 7.0</span><br><span class="line">     </span><br><span class="line">     highp vec2 texPos1;</span><br><span class="line">     texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);// 计算坐标</span><br><span class="line">     texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);</span><br><span class="line">     </span><br><span class="line">     highp vec2 texPos2;</span><br><span class="line">     texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);</span><br><span class="line">     texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);</span><br><span class="line">     </span><br><span class="line">     lowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1);</span><br><span class="line">     lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);</span><br><span class="line">     </span><br><span class="line">     lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));  //fract返回小数部分</span><br><span class="line">     gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), intensity);   //mix 根据强度混合</span><br><span class="line"> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mix 线性差值函数</span><br><span class="line">函数接口mix(x, y, level);</span><br><span class="line">x, y : 输入值</span><br><span class="line">level :  插值系数</span><br><span class="line">return : 返回插值结果</span><br><span class="line">描述 : dest = x * (1 - level) + y * level;</span><br></pre></td></tr></table></figure>
<p> ###内置滤镜<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;GPUImageBrightnessFilter.h&quot;                //亮度</span><br><span class="line">#import &quot;GPUImageExposureFilter.h&quot;                  //曝光</span><br><span class="line">#import &quot;GPUImageContrastFilter.h&quot;                  //对比度</span><br><span class="line">#import &quot;GPUImageSaturationFilter.h&quot;                //饱和度</span><br><span class="line">#import &quot;GPUImageGammaFilter.h&quot;                     //伽马线</span><br><span class="line">#import &quot;GPUImageColorInvertFilter.h&quot;               //反色</span><br><span class="line">#import &quot;GPUImageSepiaFilter.h&quot;                     //褐色（怀旧）</span><br><span class="line">#import &quot;GPUImageLevelsFilter.h&quot;                    //色阶</span><br><span class="line">#import &quot;GPUImageGrayscaleFilter.h&quot;                 //灰度</span><br><span class="line">#import &quot;GPUImageHistogramFilter.h&quot;                 //色彩直方图，显示在图片上</span><br><span class="line">#import &quot;GPUImageHistogramGenerator.h&quot;              //色彩直方图</span><br><span class="line">#import &quot;GPUImageRGBFilter.h&quot;                       //RGB</span><br><span class="line">#import &quot;GPUImageToneCurveFilter.h&quot;                 //色调曲线</span><br><span class="line">#import &quot;GPUImageMonochromeFilter.h&quot;                //单色</span><br><span class="line">#import &quot;GPUImageOpacityFilter.h&quot;                   //不透明度</span><br><span class="line">#import &quot;GPUImageHighlightShadowFilter.h&quot;           //提亮阴影</span><br><span class="line">#import &quot;GPUImageFalseColorFilter.h&quot;                //色彩替换（替换亮部和暗部色彩）</span><br><span class="line">#import &quot;GPUImageHueFilter.h&quot;                       //色度</span><br><span class="line">#import &quot;GPUImageChromaKeyFilter.h&quot;                 //色度键</span><br><span class="line">#import &quot;GPUImageWhiteBalanceFilter.h&quot;              //白平横</span><br><span class="line">#import &quot;GPUImageAverageColor.h&quot;                    //像素平均色值</span><br><span class="line">#import &quot;GPUImageSolidColorGenerator.h&quot;             //纯色</span><br><span class="line">#import &quot;GPUImageLuminosity.h&quot;                      //亮度平均</span><br><span class="line">#import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageLookupFilter.h&quot;                    //lookup 色彩调整</span><br><span class="line">#import &quot;GPUImageAmatorkaFilter.h&quot;                  //Amatorka lookup</span><br><span class="line">#import &quot;GPUImageMissEtikateFilter.h&quot;               //MissEtikate lookup</span><br><span class="line">#import &quot;GPUImageSoftEleganceFilter.h&quot;              //SoftElegance lookup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 图像处理 Handle Image</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageCrosshairGenerator.h&quot;              //十字</span><br><span class="line">#import &quot;GPUImageLineGenerator.h&quot;                   //线条</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageTransformFilter.h&quot;                 //形状变化</span><br><span class="line">#import &quot;GPUImageCropFilter.h&quot;                      //剪裁</span><br><span class="line">#import &quot;GPUImageSharpenFilter.h&quot;                   //锐化</span><br><span class="line">#import &quot;GPUImageUnsharpMaskFilter.h&quot;               //反遮罩锐化</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageFastBlurFilter.h&quot;                  //模糊</span><br><span class="line">#import &quot;GPUImageGaussianBlurFilter.h&quot;              //高斯模糊</span><br><span class="line">#import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot;     //高斯模糊，选择部分清晰</span><br><span class="line">#import &quot;GPUImageBoxBlurFilter.h&quot;                   //盒状模糊</span><br><span class="line">#import &quot;GPUImageTiltShiftFilter.h&quot;                 //条纹模糊，中间清晰，上下两端模糊</span><br><span class="line">#import &quot;GPUImageMedianFilter.h&quot;                    //中间值，有种稍微模糊边缘的效果</span><br><span class="line">#import &quot;GPUImageBilateralFilter.h&quot;                 //双边模糊</span><br><span class="line">#import &quot;GPUImageErosionFilter.h&quot;                   //侵蚀边缘模糊，变黑白</span><br><span class="line">#import &quot;GPUImageRGBErosionFilter.h&quot;                //RGB侵蚀边缘模糊，有色彩</span><br><span class="line">#import &quot;GPUImageDilationFilter.h&quot;                  //扩展边缘模糊，变黑白</span><br><span class="line">#import &quot;GPUImageRGBDilationFilter.h&quot;               //RGB扩展边缘模糊，有色彩</span><br><span class="line">#import &quot;GPUImageOpeningFilter.h&quot;                   //黑白色调模糊</span><br><span class="line">#import &quot;GPUImageRGBOpeningFilter.h&quot;                //彩色模糊</span><br><span class="line">#import &quot;GPUImageClosingFilter.h&quot;                   //黑白色调模糊，暗色会被提亮</span><br><span class="line">#import &quot;GPUImageRGBClosingFilter.h&quot;                //彩色模糊，暗色会被提亮</span><br><span class="line">#import &quot;GPUImageLanczosResamplingFilter.h&quot;         //Lanczos重取样，模糊效果</span><br><span class="line">#import &quot;GPUImageNonMaximumSuppressionFilter.h&quot;     //非最大抑制，只显示亮度最高的像素，其他为黑</span><br><span class="line">#import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //与上相比，像素丢失更多</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageSobelEdgeDetectionFilter.h&quot;        //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)</span><br><span class="line">#import &quot;GPUImageCannyEdgeDetectionFilter.h&quot;        //Canny边缘检测算法（比上更强烈的黑白对比度）</span><br><span class="line">#import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot;    //阈值边缘检测（效果与上差别不大）</span><br><span class="line">#import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot;      //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)</span><br><span class="line">#import &quot;GPUImageXYDerivativeFilter.h&quot;              //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色</span><br><span class="line">#import &quot;GPUImageHarrisCornerDetectionFilter.h&quot;     //Harris角点检测，会有绿色小十字显示在图片角点处</span><br><span class="line">#import &quot;GPUImageNobleCornerDetectionFilter.h&quot;      //Noble角点检测，检测点更多</span><br><span class="line">#import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大</span><br><span class="line">#import &quot;GPUImageMotionDetector.h&quot;                  //动作检测</span><br><span class="line">#import &quot;GPUImageHoughTransformLineDetector.h&quot;      //线条检测</span><br><span class="line">#import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageLocalBinaryPatternFilter.h&quot;        //图像黑白化，并有大量噪点</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageLowPassFilter.h&quot;                   //用于图像加亮</span><br><span class="line">#import &quot;GPUImageHighPassFilter.h&quot;                  //图像低于某值时显示为黑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 视觉效果 Visual Effect</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageSketchFilter.h&quot;                    //素描</span><br><span class="line">#import &quot;GPUImageThresholdSketchFilter.h&quot;           //阀值素描，形成有噪点的素描</span><br><span class="line">#import &quot;GPUImageToonFilter.h&quot;                      //卡通效果（黑色粗线描边）</span><br><span class="line">#import &quot;GPUImageSmoothToonFilter.h&quot;                //相比上面的效果更细腻，上面是粗旷的画风</span><br><span class="line">#import &quot;GPUImageKuwaharaFilter.h&quot;                  //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageMosaicFilter.h&quot;                    //黑白马赛克</span><br><span class="line">#import &quot;GPUImagePixellateFilter.h&quot;                 //像素化</span><br><span class="line">#import &quot;GPUImagePolarPixellateFilter.h&quot;            //同心圆像素化</span><br><span class="line">#import &quot;GPUImageCrosshatchFilter.h&quot;                //交叉线阴影，形成黑白网状画面</span><br><span class="line">#import &quot;GPUImageColorPackingFilter.h&quot;              //色彩丢失，模糊（类似监控摄像效果）</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageVignetteFilter.h&quot;                  //晕影，形成黑色圆形边缘，突出中间图像的效果</span><br><span class="line">#import &quot;GPUImageSwirlFilter.h&quot;                     //漩涡，中间形成卷曲的画面</span><br><span class="line">#import &quot;GPUImageBulgeDistortionFilter.h&quot;           //凸起失真，鱼眼效果</span><br><span class="line">#import &quot;GPUImagePinchDistortionFilter.h&quot;           //收缩失真，凹面镜</span><br><span class="line">#import &quot;GPUImageStretchDistortionFilter.h&quot;         //伸展失真，哈哈镜</span><br><span class="line">#import &quot;GPUImageGlassSphereFilter.h&quot;               //水晶球效果</span><br><span class="line">#import &quot;GPUImageSphereRefractionFilter.h&quot;          //球形折射，图形倒立</span><br><span class="line">    </span><br><span class="line">#import &quot;GPUImagePosterizeFilter.h&quot;                 //色调分离，形成噪点效果</span><br><span class="line">#import &quot;GPUImageCGAColorspaceFilter.h&quot;             //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面</span><br><span class="line">#import &quot;GPUImagePerlinNoiseFilter.h&quot;               //柏林噪点，花边噪点</span><br><span class="line">#import &quot;GPUImage3x3ConvolutionFilter.h&quot;            //3x3卷积，高亮大色块变黑，加亮边缘、线条等</span><br><span class="line">#import &quot;GPUImageEmbossFilter.h&quot;                    //浮雕效果，带有点3d的感觉</span><br><span class="line">#import &quot;GPUImagePolkaDotFilter.h&quot;                  //像素圆点花样</span><br><span class="line">#import &quot;GPUImageHalftoneFilter.h&quot;                  //点染,图像黑白化，由黑点构成原图的大致图形</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 混合模式 Blend</span><br><span class="line"></span><br><span class="line">#import &quot;GPUImageMultiplyBlendFilter.h&quot;             //通常用于创建阴影和深度效果</span><br><span class="line">#import &quot;GPUImageNormalBlendFilter.h&quot;               //正常</span><br><span class="line">#import &quot;GPUImageAlphaBlendFilter.h&quot;                //透明混合,通常用于在背景上应用前景的透明度</span><br><span class="line">#import &quot;GPUImageDissolveBlendFilter.h&quot;             //溶解</span><br><span class="line">#import &quot;GPUImageOverlayBlendFilter.h&quot;              //叠加,通常用于创建阴影效果</span><br><span class="line">#import &quot;GPUImageDarkenBlendFilter.h&quot;               //加深混合,通常用于重叠类型</span><br><span class="line">#import &quot;GPUImageLightenBlendFilter.h&quot;              //减淡混合,通常用于重叠类型</span><br><span class="line">#import &quot;GPUImageSourceOverBlendFilter.h&quot;           //源混合</span><br><span class="line">#import &quot;GPUImageColorBurnBlendFilter.h&quot;            //色彩加深混合</span><br><span class="line">#import &quot;GPUImageColorDodgeBlendFilter.h&quot;           //色彩减淡混合</span><br><span class="line">#import &quot;GPUImageScreenBlendFilter.h&quot;               //屏幕包裹,通常用于创建亮点和镜头眩光</span><br><span class="line">#import &quot;GPUImageExclusionBlendFilter.h&quot;            //排除混合</span><br><span class="line">#import &quot;GPUImageDifferenceBlendFilter.h&quot;           //差异混合,通常用于创建更多变动的颜色</span><br><span class="line">#import &quot;GPUImageSubtractBlendFilter.h&quot;             //差值混合,通常用于创建两个图像之间的动画变暗模糊效果</span><br><span class="line">#import &quot;GPUImageHardLightBlendFilter.h&quot;            //强光混合,通常用于创建阴影效果</span><br><span class="line">#import &quot;GPUImageSoftLightBlendFilter.h&quot;            //柔光混合</span><br><span class="line">#import &quot;GPUImageChromaKeyBlendFilter.h&quot;            //色度键混合</span><br><span class="line">#import &quot;GPUImageMaskFilter.h&quot;                      //遮罩混合</span><br><span class="line">#import &quot;GPUImageHazeFilter.h&quot;                      //朦胧加暗</span><br><span class="line">#import &quot;GPUImageLuminanceThresholdFilter.h&quot;        //亮度阈</span><br><span class="line">#import &quot;GPUImageAdaptiveThresholdFilter.h&quot;         //自适应阈值</span><br><span class="line">#import &quot;GPUImageAddBlendFilter.h&quot;                  //通常用于创建两个图像之间的动画变亮模糊效果</span><br><span class="line">#import &quot;GPUImageDivideBlendFilter.h&quot;               //通常用于创建两个图像之间的动画变暗模糊效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 尚不清楚</span><br><span class="line">#import &quot;GPUImageJFAVoroniFilter.h&quot;</span><br><span class="line">#import &quot;GPUImageVoroniConsumerFilter.h&quot;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/26/GPUImage学习笔记（2）/" data-id="ckbnff0yr0011lwj77qmnrrnh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GPUImage学习笔记（1）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/24/GPUImage学习笔记（1）/" class="article-date">
  <time datetime="2018-05-24T02:53:58.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/24/GPUImage学习笔记（1）/">GPUImage学习笔记（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>断断续续看了也有一段时间了，画了无数个三角形了。。不得不记录一下。</p>
<h2 id="opengl-vs-opengles"><a href="#opengl-vs-opengles" class="headerlink" title="opengl vs opengles"></a>opengl vs opengles</h2><p>opengl是什么？Open Graphics Library，一般可以认为它是一个操作图形图像的API。他的具体实现由显卡厂商实现，当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。<br>opengles呢？opengl for Embedded Systems，它是opengl的一个子集，针对手机等嵌入式系统而设计的。去除了一些非必要的特性。</p>
<h2 id="opengles的版本"><a href="#opengles的版本" class="headerlink" title="opengles的版本"></a>opengles的版本</h2><p>opengles1.x 是针对固定管线，opengles2.x 是针对可编程管线，opengles3.x相比2.x增加了新特性。目前使用比较广泛的还是2.x。</p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>opengl本质是一个大的状态机。一系列的变量描绘了opengl此刻如何应该去工作。opengl的状态通常被称为上下文Context。</p>
<h2 id="创建opengl的对象"><a href="#创建opengl的对象" class="headerlink" title="创建opengl的对象"></a>创建opengl的对象</h2><p>首先要说明的是，其实对于c来说并不存在对象，最多也只是结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> objectId = <span class="number">0</span>;</span><br><span class="line">glGenObject(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// 绑定对象至上下文</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line">glBindObject(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>创建一个对象，用objectId来保存生成对象的引索（opengl会依次生成index，比如1，2，3）</li>
<li>这个对象和opengl的上下文绑定起来，使得opengl这个状态机某个具体的Target,引索到具体的对象。</li>
<li>设置这个Target一些选项，实际上通过引索赋值到对象上了。</li>
<li>解除上下文和这个对象的绑定，0这个index是opengl保留的，其大部分的作用就是用来解绑。</li>
</ol>
<h2 id="视口viewport"><a href="#视口viewport" class="headerlink" title="视口viewport"></a>视口viewport</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glViewport (GLint x, GLint y, GLsizei width, GLsizei height);</span><br></pre></td></tr></table></figure>
<p>glViewport函数前两个参数控制窗口左下角的位置。第三个和第四个参数控制渲染窗口的宽度和高度（像素）。</p>
<blockquote>
<blockquote>
<p>我看到相机应用中16：9， 1：1这样的设置的时候，我觉得可能是在改变这个值。</p>
</blockquote>
</blockquote>
<h2 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h2><p>我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来。</p>
<h2 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT);</span><br></pre></td></tr></table></figure>
<p>我们可以通过调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p>
<h2 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h2><p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<p>顶点数据 ==&gt; 顶点着色器 ==&gt; 图元装配 ==&gt; 几何着色器 ==&gt; 光栅化 ==&gt; 片段着色器 ==&gt; 测试和混合</p>
<p>图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p>
<h2 id="顶点缓冲对象VBO"><a href="#顶点缓冲对象VBO" class="headerlink" title="顶点缓冲对象VBO"></a>顶点缓冲对象VBO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个buffer对象,相当于申请一个显存（此时还未分配空间）</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从cpu向gpu传递数据</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<h2 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h2><p>program<br>vertex shader<br>fragment shader</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建shader程序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶点shader，注入代码，编译</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建偏远shader，注入代码，编译</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个shader附着到程序上</span></span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// link程序</span></span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用程序</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接完其实就可以删除shader了</span></span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure>
<h2 id="链接顶点属性，告诉opengl如何解释在VBO中的数据"><a href="#链接顶点属性，告诉opengl如何解释在VBO中的数据" class="headerlink" title="链接顶点属性，告诉opengl如何解释在VBO中的数据"></a>链接顶点属性，告诉opengl如何解释在VBO中的数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>glVertexAttribPointer<br>第一个参数，对应于vertex shader中属性的位置，也就是说顶点数据对应shader中哪个变量能访问到<br>第二个参数，顶点属性的大小<br>第三个参数，顶点属性的数据类型<br>第四个参数，是否归一化<br>第五个参数，顶点数据的步长，（因为顶点数据可以包含，坐标啊，颜色啊，等任何数据，每一整块是等长的）<br>第六个参数，在一整块数据中的偏移，（比如前三个是3d坐标</p>
<p>还有一个问题，怎么关联起来的呢？<br>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVetexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVetexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。</p>
<h2 id="顶点数组对象VAO"><a href="#顶点数组对象VAO" class="headerlink" title="顶点数组对象VAO"></a>顶点数组对象VAO</h2><p>用来管理VBO的</p>
<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>纹理是一个2D图片（甚至也有1D和3D的纹理）</p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样</p>
<ol>
<li><p>纹理环绕方式（GL_REPEAT，GL_MIRRORED_REPEAT，GL_CLAMP_TO_EDGE，GL_CLAMP_TO_BORDER）<br>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</p>
</li>
<li><p>纹理过滤（GL_LINEAR，GL_NEAREST）<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</p>
</li>
<li><p>加载纹理<br>unsigned int texture;<br>glGenTextures(1, &amp;texture);<br>glBindTexture(GL_TEXTURE_2D, texture);<br>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);<br>glGenerateMipmap(GL_TEXTURE_2D);</p>
</li>
<li><p>纹理单元（0-31）<br>一个纹理的默认纹理单元是0，它是默认的激活纹理单元<br>glActiveTexture(GL_TEXTURE0);<br>glUniform1i(glGetUniformLocation(ourShader.ID, “texture1”), 0);</p>
</li>
</ol>
<h2 id="变换-amp-坐标-amp-摄像机"><a href="#变换-amp-坐标-amp-摄像机" class="headerlink" title="变换&amp;坐标&amp;摄像机"></a>变换&amp;坐标&amp;摄像机</h2><p>待续…<br>本质上可以看成一系列矩阵变换</p>
<h2 id="帧缓存对象"><a href="#帧缓存对象" class="headerlink" title="帧缓存对象"></a>帧缓存对象</h2><p>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/24/GPUImage学习笔记（1）/" data-id="ckbnff0xa0006lwj7j6lx6uj8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-dlib-iOS人脸特征识别环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/dlib-iOS人脸特征识别环境搭建/" class="article-date">
  <time datetime="2018-05-17T03:30:14.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/dlib-iOS人脸特征识别环境搭建/">dlib+iOS人脸特征识别环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一个警告：这些来自相机的样本旋转了 90 度，这是由于相机传感器的朝向所导致的。</p>
<p>最近在研究人脸识别，有点懵逼哈。。</p>
<p>我大概将整个流程分成两个部分</p>
<ol>
<li>人脸识别，这个opencv可以做但是CPU的消耗170%真的是不敢恭维，系统的AVCaptureMetadataOutput中AVMetadataObjectTypeFace也是可以做的，而且效果更好。</li>
<li>特征检测，当得到人脸的矩形以后，这一步的工作就是识别各个部位的位置这个由dlib完成</li>
</ol>
<p>废话不多说进入主题dlib</p>
<ol>
<li><p>这是库地址<a href="https://github.com/davisking/dlib" target="_blank" rel="noopener">dlib</a></p>
</li>
<li><p>下载这个库</p>
</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/davisking/dlib.git</span><br></pre></td></tr></table></figure>
<ol>
<li><p>然后需要安装cmake，已经安装的忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后生成XCode的项目<br>mkdir build &amp;&amp; cd build<br>cmake -G Xcode ..<br>cmake –build . –config Release 或者 Debug</p>
</li>
<li><p>新建一个空的iOS工程<br>新建一个lib文件夹，将libdlib.a拖进去<br>build settings中 search path library search paths 和 header search paths添加 $(PROJECT_DIR)/lib<br>macros中添加 DLIB_NO_GUI_SUPPORT, DLIB_JPEG_SUPPORT, NDEBUG, DLIB_USE_BLAS, DLIB_USE_LAPACK</p>
</li>
<li><p>也是折腾了一会的因为我们要使用DlibWrapper这个文件<br>Build Phases中 Link Binary With Libraries 添加 CoreMedia.framework Accelerate.framework这两个库</p>
</li>
</ol>
<p>顺利的话应该是可以了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/17/dlib-iOS人脸特征识别环境搭建/" data-id="ckbnff0xu000klwj7c0vhyzno" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-opencv学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/opencv学习笔记/" class="article-date">
  <time datetime="2018-05-14T02:07:13.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/opencv学习笔记/">opencv学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>首先到opencv的GitHub主页 <a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">https://github.com/opencv/opencv</a></p>
</li>
<li><p>到你想存放的目录下执行</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>当你的代码下载完成之后cd到opencv目录下，创建一个新的目录可以叫做build或者release， 使用cmake将代码安装到/usr/local目录下</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br><span class="line"><span class="built_in">cd</span> opencv</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个工程，首先将一个使用opencv的.m文件后缀改成.mm，</p>
</li>
</ol>
<p>更改Build Settings中<br>Header Search Paths —&gt; /usr/local/include<br>Library Search Paths —&gt; /usr/local/lib</p>
<p>更改Build Phases中<br>Link Binary With Libraries —&gt;<br>Click “+”<br>Click “Add Other”,Cmd + shift + G ===&gt; “/usr/local/lib”,勾选opencv相关的库文件</p>
<ol>
<li>在mm文件中，import文件，记住顺序也不能颠倒~~</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>build不出意外应该是成功了</li>
</ol>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="平滑处理"><a href="#平滑处理" class="headerlink" title="平滑处理"></a>平滑处理</h3><ol>
<li>简单模糊 param1*param2邻域求和求平均</li>
<li>简单无缩放变换的模糊 param1*param2领域求和，不求平均</li>
<li>中值滤波</li>
<li>高斯滤波 高斯分布的核</li>
<li>双边滤波 邻域的加权平均值，一部分也高斯平滑相同，另一部分其他像素点和中心像素点的亮度差值加权</li>
</ol>
<h3 id="图像形态学"><a href="#图像形态学" class="headerlink" title="图像形态学"></a>图像形态学</h3><p>膨胀 图像A与核卷积，计算核B覆盖区域的像素最大值<br>腐蚀 图像A与核卷积，计算核B覆盖区域的像素最小值</p>
<p>开运算 先腐蚀再膨胀<br>闭运算 先膨胀在腐蚀<br>梯度 膨胀-腐蚀<br>礼帽 src - 开运算<br>黑帽 闭运算 - src</p>
<h3 id="漫水填充算法"><a href="#漫水填充算法" class="headerlink" title="漫水填充算法"></a>漫水填充算法</h3><h3 id="尺寸调整"><a href="#尺寸调整" class="headerlink" title="尺寸调整"></a>尺寸调整</h3><h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><h3 id="阈值化"><a href="#阈值化" class="headerlink" title="阈值化"></a>阈值化</h3><h3 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/opencv学习笔记/" data-id="ckbnff0y2000slwj7eu8onx61" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ARKit学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/ARKit学习笔记/" class="article-date">
  <time datetime="2018-05-09T07:04:42.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/ARKit学习笔记/">ARKit学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>组里让调研一下AR相关的知识，em…我一开始是拒绝的，我现在也是拒绝的。摸不清门道，感觉回到了我之前刚学习iOS的时候，有种有力使不出的感觉，挫败感很强，很浮躁。<br>但是这是任务，并不是兴趣，所以硬着头皮也得啃一啃。</p>
<p>ARKit是建立在SceneKit的基础之上的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/09/ARKit学习笔记/" data-id="ckbnff0wq0000lwj7xt4wvnrc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JLRoutes源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/02/JLRoutes源码学习/" class="article-date">
  <time datetime="2018-05-02T09:21:46.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/02/JLRoutes源码学习/">JLRoutes源码学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前也看过一些模块化的文章，围观过一些切磋。自己并没有实际的使用过，主流的框架是MGJRouter, CTMediator, JLRoutes。简单来说，我还是喜欢star比较多的项目（star党）。<br>这里来学习一下项目中使用的JLRoutes框架，不知道为什么，总觉得在使用的时候总感觉怪怪的，今天就来读一下源码看看是否能解决一下心中疑惑。</p>
<p>首先这个库的目的是为了解决外部跳转到App内部的场景，打一个比方，在我们使用微信的分享的时候，我们直接跳转到了微信对应的页面，而不是仅仅进入到首页，然后需要我们手动点击跳转目标页面。那么怎么做到的呢？只有一个途径就是openurl的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *, id&gt; *)options</span><br></pre></td></tr></table></figure>
<p>首先我们需要在我们的Info.plist中添加URL schemes。这样在iPhone的其他应用就可以通过这个schemes(注意这是一个数组，意思就是同一个app可以有多个scheme)识别需要打开的应用，然后跳转过去。比如在safari中直接输入，这个scheme下的url即可。那么问题来了，调用了系统的这个方法之后，怎么才能根据url跳转到对应的页面呢？就是下面的这一句代码了，这么厉害，一句搞定？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[JLRoutes routeURL:url];</span><br></pre></td></tr></table></figure>
<p>非也非也。具体执行的时候还是需要先注册，再跳转。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addRoute:(NSString *)routePattern handler:(BOOL (^)(NSDictionary&lt;NSString *, id&gt; *parameters))handlerBlock</span><br></pre></td></tr></table></figure>
<p>这是注册的时候的一个入口函数，框架的demo,使用的是在didFinishLanuch中注册。个人觉得，放在module的load方法中注册应该会更好一些，更分散，而不是集中的一坨。这个方法最终会调用到下面这个方法。默认传了一个O的优先级而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addRoute:(NSString *)routePattern priority:(NSUInteger)priority handler:(BOOL (^)(NSDictionary&lt;NSString *, id&gt; *parameters))handlerBlock</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个JLRRouteDefinition的对象，这其中包含了patter, priority,和handlerBlock</li>
<li>register这个route, 会根据priority往mutableRoutes中添加route, 给route添加scheme</li>
</ol>
<p>前面注册就到此为止了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)_routeURL:(NSURL *)URL withParameters:(NSDictionary *)parameters executeRouteBlock:(BOOL)executeRouteBlock;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>参数检查</li>
<li>根据url, options, parameters, 生成request对象</li>
<li>遍历mutableRoutes, 检查route和request是否匹配，（各种循环，看晕了👀）</li>
<li>匹配之后执行handlerBlock, 根据return值，决定是否需要继续遍历</li>
</ol>
<p>总结一下，本质上就是register 一个route 到 mutableRoutes的数组中，然后通过短链调用的时候生成request-&gt;response,然后遍历匹配mutableRoutes。代码清晰易读。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/02/JLRoutes源码学习/" data-id="ckbnff0xf0009lwj79i8w5or7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-YYModel源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/28/YYModel源码学习/" class="article-date">
  <time datetime="2018-04-28T02:15:28.000Z" itemprop="datePublished">2018-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/28/YYModel源码学习/">YYModel源码学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>项目里面居然还是手动解析服务端返回的json，简直不能忍受那些重复的代码。<br>现在市面OC上比较主流应该是MJExtension和YYModel了吧。（当然Swift应该是SwiftyJson，当前的工作栈主要是OC，就以YYModel入手了）</p>
<p>这是一个NSObject的Category,这也是YYModel的核心，因为它是通过runtime实现反射来实现的。<br>先看这个入口函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)yy_modelWithJSON:(id)json;</span><br><span class="line">+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json</span><br><span class="line">+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary;</span><br></pre></td></tr></table></figure>
<p>注意一下，这里传入的是一个id类型，参数名为json的对象。好吧，我就不卖关子了，json是有两种形态的，一个是json对象形态NSDictionary，另一种就是字符串形态NSString，除此以外这里也处理json字符串UTF8编码后的NSData。</p>
<p>所以第二个方法的工作就是将上述的所有的形态，转换成一个NSDictionary。也就是下面这个api的作用了。</p>
<p>然后就是根据NSDictionary生成Model了。</p>
<ol>
<li>根据惯例，首先是参数检查。</li>
<li>获得当前的Class</li>
<li>根据Class生成一个_YYModelMeta的对象，从名字看出他是这个类的元信息。</li>
<li>检查是否有自定义的Class去从字典转换</li>
<li>创建一个对象</li>
<li>给这个新的对象赋值，并返回</li>
</ol>
<p>首先来看这个_YYModelMeta对象吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)metaWithClass:(Class)cls;</span><br><span class="line">- (instancetype)initWithClass:(Class)cls;</span><br></pre></td></tr></table></figure></p>
<p>这里实用类方法，主要目的是增加一个缓存，提高效率。</p>
<ol>
<li>根据惯例，首先是参数检查。</li>
<li>使用单例，生成cache, lock。这个锁是基于信号量的。</li>
<li>加锁，从cache中寻找meta，解锁 （这一步提高性能）</li>
<li>如果没有找到meta,或者meta需要更新</li>
<li><p>生成meta,cache这个生成的meta，然后return</p>
<p> 生成meta的方法如下</p>
<ol>
<li><p>首先获得YYClassInfo, 没有则return nil<br> 这里还涉及一个YYClassInfo的创建,这里有三个容器，ivarInfos, methodInfos, propertyInfos，前两个感觉没啥用啊</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)classInfoWithClass:(Class)cls;</span><br><span class="line">- (instancetype)initWithClass:(Class)cls;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建classCache, metaCache, 锁</li>
<li>使用单例初始化</li>
<li>加锁，读cache</li>
<li>创建info, 设置cache<ol>
<li>参数检查</li>
<li>设置cls, superCls, 设置isMeta，不是meta获得metaCls, 获得类名</li>
<li>update，methodInfos, propertyInfos, ivarInfos</li>
<li>获得父类的ClassInfo</li>
</ol>
</li>
</ol>
</li>
<li>获取黑名单</li>
<li>获取白名单</li>
<li>获取容器中的类型，key比如得是属性名，value可以由Class或者是这个Class名字的字符串转成Class</li>
<li><p>建立一个属性的allPropertyMetas字典，遍历继承链，遍历propertyInfos，过滤 没有属性名，有黑名单并在名单中，有白名单不在名单中，生成属性meta, 过滤 属性meta不存在或者没有名字，meta没有getter或者setter，已存在（所以子类覆盖父类）。<br> 根据propertyInfo,生成_YYModelPropertyMeta</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)metaWithClassInfo:(YYClassInfo *)classInfo propertyInfo:(YYClassPropertyInfo *)propertyInfo generic:(Class)generic</span><br></pre></td></tr></table></figure>
</li>
<li><p>将结果存在_allPropertyMetas中可以为属性名，value 为propertyMeta</p>
</li>
<li>建立三个字典mapper，keyPathPropertyMetas，multiKeysPropertyMetas，主要处理keyPath的情况</li>
<li>判断是否有自定义Mapper,如果存在自定义customMapper,遍历<ol>
<li>从属性allPropertyMetas中找到PropertyMeta</li>
<li>将其从中移除</li>
<li>如果是字符串，判空，设置key, 判断是否是keypath,设置keyPath，设置_next, 设置mapper,key为keypath,value为propertyMeta</li>
<li>如果是数组，遍历，参数检查，判断到底是key还是keyPath, 设置mappedTokey属性，设置_next, 设置mapper</li>
</ol>
</li>
<li>设置mapper, keyPathPropertyMetas, multiKeysPropertyMetas</li>
<li>设置一系列属性</li>
</ol>
</li>
</ol>
<p>上部分主要是对这个类进行各种解析，接下去的我们就是创建一个对象，然后给这个对象赋值。<br>这里首先创建一个context，这个其中包含了modelMeta, model(创建出来的对象)，dictionary（一般是服务端返回）</p>
<p>这里根据_keyMappedCount和dic的数目对比，进行不同的处理，这里的遍历使用apply的方式。感觉是为了速度。</p>
<p>分不同的情况分别调用了，下面的两个方法  这里都是使用inline函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModelSetWithDictionaryFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *_key, <span class="keyword">const</span> <span class="keyword">void</span> *_value, <span class="keyword">void</span> *_context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModelSetWithPropertyMetaArrayFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *_propertyMeta, <span class="keyword">void</span> *_context)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>最后的最后都会走到这个方法上来，这个方法针对不同的value的可能性通过setter方法给其赋值。<br>如果是容器，会使用_genericCls的class,递归调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModelSetValueForProperty</span><span class="params">(__unsafe_unretained id model,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     __unsafe_unretained id value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     __unsafe_unretained _YYModelPropertyMeta *meta)</span></span></span><br></pre></td></tr></table></figure></p>
<p>最后一步就是自定义处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/28/YYModel源码学习/" data-id="ckbnff0xt000jlwj7x8cxp6mz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/20/常见iOSUI方案/">常见iOSUI方案</a>
          </li>
        
          <li>
            <a href="/2019/11/16/记一次MethodSwizzle的bugfix/">记一次MethodSwizzle的bugfix</a>
          </li>
        
          <li>
            <a href="/2019/10/27/MacBook-Pro-Retina-13-inch-Early-2015-更换ssd/">MacBook Pro(Retina, 13-inch, Early 2015)更换ssd</a>
          </li>
        
          <li>
            <a href="/2019/10/16/iOS证书和推送/">iOS证书和推送</a>
          </li>
        
          <li>
            <a href="/2019/06/06/CocoaPods/">CocoaPods</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 hust_destiny<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>