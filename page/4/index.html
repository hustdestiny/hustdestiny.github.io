<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Destiny</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Destiny">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Destiny">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Destiny">
  
    <link rel="alternate" href="/atom.xml" title="Destiny" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Destiny</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-OC之Block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/28/OC之Block/" class="article-date">
  <time datetime="2017-09-28T04:12:05.000Z" itemprop="datePublished">2017-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/28/OC之Block/">OC之Block</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Block的结构"><a href="#Block的结构" class="headerlink" title="Block的结构"></a>Block的结构</h2><p>首先来说，block也是一个对象，因为它也有isa指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// revised new layout</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> // 引用了外部变量才会有<span class="title">copy</span>和<span class="title">dispose</span>函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> 			// <span class="title">block</span>对应的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// 以下三种类型</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Block的种类"><a href="#Block的种类" class="headerlink" title="Block的种类"></a>Block的种类</h2><p>_NSConcreteGlobalBlock。     //1. 全局Block,分布在数据区;2.函数内部定义，没有引用任何外部变量。<br>_NSConcreteStackBlock。      //1. 通过copy分配到stack上的Block。<br>_NSConcreteMallocBlock。     //1. 其他</p>
<h2 id="Block-从stack中copy到heap上"><a href="#Block-从stack中copy到heap上" class="headerlink" title="Block 从stack中copy到heap上"></a>Block 从stack中copy到heap上</h2><p>将block赋给strong类型的变量时，编译器会自动将其copy到heap上。<br>block作为函数的参数、为__weak类型的block变量赋值, 编译器不会自动copy。<br>将_NSConcreteStackBlock类型的block copy到heap上变成_NSConcreteMallocBlock类型的block时，会retain其引用的外部object。</p>
<h3 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h3><p>block进行多次copy都不会有问题</p>
<h2 id="Block-内部可以修改的的外部变量"><a href="#Block-内部可以修改的的外部变量" class="headerlink" title="Block 内部可以修改的的外部变量"></a>Block 内部可以修改的的外部变量</h2><ol>
<li>全局变量、全局静态变量、静态变量以及类的成员变量。</li>
<li><p>用__block修饰的自变量。仅仅是这个变量自身（而不是指向的对象）会被转成一个结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_blockArr_0</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_blockArr_0 *__forwarding;</span><br><span class="line"><span class="keyword">int</span> __flags;</span><br><span class="line"><span class="keyword">int</span> __size;</span><br><span class="line"><span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"><span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line">NSArray *blockArr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*blockA)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0(</span><br><span class="line">        (<span class="keyword">void</span> *)__main_block_func_0, </span><br><span class="line">        &amp;__main_block_desc_0_DATA, </span><br><span class="line">        (__Block_byref_blockArr_0 *)&amp;blockArr,</span><br><span class="line">        <span class="number">570425344</span>)</span><br><span class="line">     );</span><br><span class="line"></span><br><span class="line">__main_block_desc_0_DATA = &#123; </span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    <span class="keyword">sizeof</span>(struct __main_block_impl_0), </span><br><span class="line">    __main_block_copy_0, </span><br><span class="line">    __main_block_dispose_0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign(</span><br><span class="line">        (<span class="keyword">void</span>*)&amp;dst-&gt;blockArr, </span><br><span class="line">        (<span class="keyword">void</span>*)src-&gt;blockArr, </span><br><span class="line">        <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>block变量会随block copy到heap而同样被copy到heap上。其最终会调用到_Block_object_assign函数。<br>因此，在此情况下就存在同时访问stack上和heap上 </strong>block变量的情况。这就是 <strong>forwarding指针的使命所在。<br>当block变量从stack到copy到heap上时，stack上的forwarding被修改为指向heap上的block变量。通过该机制（stack中访问的是p.</strong>forwarding.p, heap中直接是p），使得无论是在stack上还是heap上都能访问到同一个(heap上)block变量（stack上的变量常规方式已经不可访问）。</p>
</li>
</ol>
<p>体会一下。blockStr.__forwarding-&gt;blockStr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableString *str = [NSMutableString stringWithFormat:@&quot;123&quot;];</span><br><span class="line">    __block NSMutableString *blockStr = str;</span><br><span class="line">    void (^blockB)(void) = ^&#123;</span><br><span class="line">        [blockStr appendString:@&quot;4&quot;];</span><br><span class="line">        blockStr = [NSMutableString stringWithFormat:@&quot;321&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;, blockStr);// 321</span><br><span class="line">    &#125;;</span><br><span class="line">    blockB();</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);//1234</span><br><span class="line">    NSLog(@&quot;%@&quot;, blockStr);//321</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *str = ((NSMutableString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSMutableString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_15_yqh06lds04g5mgfqn8x8s5k40000gn_T_main_9c0693_mi_0);</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_blockStr_0 blockStr = &#123;(void*)0,(__Block_byref_blockStr_0 *)&amp;blockStr, 33554432, sizeof(__Block_byref_blockStr_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, str&#125;;</span><br><span class="line">    void (*blockB)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_blockStr_0 *)&amp;blockStr, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blockB)-&gt;FuncPtr)((__block_impl *)blockB);</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_15_yqh06lds04g5mgfqn8x8s5k40000gn_T_main_9c0693_mi_4, str);</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_15_yqh06lds04g5mgfqn8x8s5k40000gn_T_main_9c0693_mi_5, (blockStr.__forwarding-&gt;blockStr));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Block-捕获的普通变量"><a href="#Block-捕获的普通变量" class="headerlink" title="Block 捕获的普通变量"></a>Block 捕获的普通变量</h2><ol>
<li>retain了block内引用的对象</li>
<li>将源block中object的地址赋给了目标block中的object变量</li>
</ol>
<h2 id="关于一个Timer的问题"><a href="#关于一个Timer的问题" class="headerlink" title="关于一个Timer的问题"></a>关于一个Timer的问题</h2><p>Q: 如果寄希望在dealloc去invalidate timer只能循环引用了。<br>A: 为什么？因为runloop（强引用）timer, timer（强引用）self。这里有两个前提1是强引用一个weakSelf会使得引用计数+1（这就是什么你传一个weakSelf作为target也不行的原因），2invalidate会释放runloop对timer的持有，并释放对self的持有。<br>解决的方案有很多，但是目的只有一个就是适当的时间invalidate, 比如viewWillDisappear中。但是就想在dealloc中呢，那应该用一个Proxy对象，让timer(强引用)proxy,这样self中的dealloc就会执行.那么问题来了，为什么block中weakSelf就不会使得引用计数+1呢？strongSelf又在干什么呢？strongSelf是为了防止在Block执行过程中使用。在block中,block是对变量进行捕获,意思是对使用到的变量进行拷贝操作,注意是拷贝的不是对象,而是变量自身,拿上面的来说,block中只是对变量wself拷贝了一份,也就是说,block中也定义了一个weak对象,相当于,在block的内存区域中,定义了一个__weak blockWeak对象,然后执行了blockWeak = wself;注意到了没,这里并没有引起对象的持有量的变化,所以没有问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/28/OC之Block/" data-id="ck28skzqh000b0cz6iyja0my7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OC之Runtime" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/27/OC之Runtime/" class="article-date">
  <time datetime="2017-09-27T01:57:01.000Z" itemprop="datePublished">2017-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/27/OC之Runtime/">OC之Runtime</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>做一个技术总结，总是零零散散的看到各种博客讲rumtime。其中不乏大牛讲的非常棒。但是自己不动手总是别人的，如何才能变成自己的呢，那就得自己捕鱼造轮子咯。</p>
<p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a></p>
<h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>在OC中什么是对象（喂，我不是故意的好嘛！）。有isa指针的都是对象，这里的isa其实是is a pointer的简写，它指向他的Class。</p>
<p>首先在源码中，objc-private.h 文件中。<br>line-51，我发现了两个经常使用的Class和id的申明，熟悉c++的朋友，应该能区分申明（declaration）和定义（definition）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>
<p>按住CMD点击跳转到objc_object的declaration处，同文件line-168，我们可以看到objc_object的本质是一个结构体，并且它只有一个私有成员isa，当然还包含许多的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的方式，我们在objc-runtime-new.h，line-1060，我们可以看到objc_class的definition，它是继承自objc_object的。<em>注意（敲黑板）</em>其实类也是一个对象！</p>
<ol>
<li>当我们调用某一个对象的instance方法的时候，它会通过它的isa找到它的Class, 并在方法列表中查找。（当然找不到的话，还会super Class，最后还有消息转发机制，以后再聊）</li>
<li>当我们调用一个类的Class方法的时候，它会通过它的isa找到它的MetaClass, 并在方法列表中查找。</li>
<li>MetaClass的isa指向哪里呢？指向RootMetaClass。what❓感觉是无穷无尽的。别着急，其实在OC中有两个RootClass, 一个是NSObject（另一个是NSProxy以后再聊)，它的isa其实就是RootMetaClass, 它的super指向nil。 RootMetaClass的isa指向自己，它的super指向NSObject。至此形成了一个完整的结构。</li>
</ol>
<p>盗一张经典图。</p>
<img src="/2017/09/27/OC之Runtime/object_model.png">
<p>对象的内存模型是啥样的呢？<br>对象成员变量从根类开始依次排列（isa就是根类NSObject的成员变量，也就是指向对象的类）</p>
<p>方法调用的原理，isa指针在方法表中寻找，优化先找cache</p>
<h2 id="Category-和-Associated-Objects"><a href="#Category-和-Associated-Objects" class="headerlink" title="Category 和 Associated Objects"></a>Category 和 Associated Objects</h2><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>使用场景</p>
<ol>
<li>给现有的类添加方法</li>
<li>将一个类的实现，拆分成多个独立的文件。（这点对比Swift的extension）</li>
</ol>
<p>其实现原理，第一步为目标Class注册category, 第二步重建Class的方法列表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachCategories</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)                 <span class="comment">//注意此处是一个二级指针，它指向一个方法，属性，协议列表的指针，分配count个指针的大小空间</span></span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));                  <span class="comment">//使得每一个category文件方法，属性，协议在一个二级指针下。</span></span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;                                               <span class="comment">//0. 反向构建。新的categories在最前面。（这个顺序和Build Phases中的Compile Source中的顺序有关）</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;                           <span class="comment">//1. 加到方法列表中，构建mlists包含所有category的方法</span></span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);                    <span class="comment">//2. 添加到方法列表中去</span></span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;                      <span class="comment">// 3** 已经存在list了，list.count &gt; 1</span></span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));          <span class="comment">//3. 往后挪动增加方法的位置。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));        <span class="comment">//4. 将增加的方法添加到最前面。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123; <span class="comment">// 1** 之前没有list, 并且添加数目为1</span></span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;                                 <span class="comment">// 2** 没有list或者list.count = 1</span></span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));<span class="comment">//5. 分配新数目的空间</span></span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;      <span class="comment">//6. 如果有一个方法则移动到最后去</span></span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists,                      <span class="comment">//7. 将添加的方法内存copy到最前面去</span></span><br><span class="line">                addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Associated-Objects"><a href="#Associated-Objects" class="headerlink" title="Associated Objects"></a>Associated Objects</h3><p>为什么需要使用AssociatedObjects,因为Class的实例变量一旦确定就不能再添加了。</p>
<p>它最主要也是用来实现这个功能，为现有的类添加公有属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是目标对象<br>第二个参数是key, 对象级别的常量<br>第三个参数是需要添加的属性<br>第四个参数是关联策略，命名已经很清晰了。</p>
<p>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的</p>
<h2 id="load、initialize-和-Method-Swizzling"><a href="#load、initialize-和-Method-Swizzling" class="headerlink" title="load、initialize 和 Method Swizzling"></a>load、initialize 和 Method Swizzling</h2><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>load方法的调用顺序是，先super,再child,最后再category。下面的递归是为了super和child的顺序，在调用的时候最后会调用category的load</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>initialize是类或者它的子类收到第一条消息的时候调用的。也就是说它是懒加载的，它是走的消息流程objc_msgSend。<br>可以用来初始化一些静态变量（使用不是很多啊）。</p>
<h3 id="MethodSwizzling"><a href="#MethodSwizzling" class="headerlink" title="MethodSwizzling"></a>MethodSwizzling</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;                              // 1.当类加载到runtime的时候</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;            // 2.保证只执行一次</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        //3. SEL结构。 typedef struct objc_selector *SEL; 我的理解就是一个字符串。</span><br><span class="line">        //4. Method结构。 typedef struct method_t *Method; struct method_t &#123; SEL name, const char * types, IMP imp &#125;;</span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);  // 5. 获取目标方法的SEL</span><br><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);// 6. 获取替换的方法的SEL</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector); // 7. 获取目标方法的Method.</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 8. 获取替换方法的Method。</span><br><span class="line">        // 9.找到的originalSelector可能是父类的实现，子类根本没有实现</span><br><span class="line">        // 10.当前类没有此方法，originalMethod是父类的。 didAddMethod === true，去replace。</span><br><span class="line">        // 11.当前类有此方法，originalMethod是自身的。 didAddMethod === false，直接exchangeImp。</span><br><span class="line">        BOOL didAddMethod =</span><br><span class="line">            class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));        // 12.给当前类目标SEL增加一个替换IMP</span><br><span class="line">        if (didAddMethod) &#123;                                     // 13. 若添加成功了，再把替换SEL换成目标的方法</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                swizzledSelector,</span><br><span class="line">                method_getImplementation(originalMethod),</span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;                                                // 13. 若添加不成功，直接交换两个的实现。</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];                         // 14. 为什么是个递归呢，其实内部的调用，已经是替换过的了。</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Autorelease-Pool和-runloop"><a href="#Autorelease-Pool和-runloop" class="headerlink" title="Autorelease Pool和 runloop"></a>Autorelease Pool和 runloop</h2><p>Autorelease对象什么时候释放？<br>在没有手动Autorelease Pool的情况下，它是在runloop迭代结束的时候释放。</p>
<h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p>AutoreleasePool是一个由AutoreleasePoolPage为节点组成的双向链表。分配4096的空间，除了自身占用一部分外，其他空间作为一个栈结构，存即将释放的对象指针。</p>
<p>objc_autoreleasePoolPush 在page中添加一个哨兵对象，返回这个哨兵对象的地址context。<br>objc_autoreleasePoolPop(context), 根据哨兵对象，哨兵之后的统一发release消息。反过来一直清理至哨兵。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);                  <span class="comment">//page中直接加入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);  <span class="comment">//新建一个page</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);          <span class="comment">//初始化一个page</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h3><p>在主线程的runloop中，每一个eventloop开始前，系统会自动创建一个autoreleasepool,并且eventloop结束是drain。每个autoreleasepoll对应一个线程。</p>
<h2 id="KVO和KVC"><a href="#KVO和KVC" class="headerlink" title="KVO和KVC"></a>KVO和KVC</h2><h3 id="KVO的原理"><a href="#KVO的原理" class="headerlink" title="KVO的原理"></a>KVO的原理</h3><ol>
<li>当一个object有观察者时，动态创建这个object的类的子类</li>
<li>对于每个被观察的property，重写其set方法</li>
<li>在重写的set方法中调用- willChangeValueForKey:和- didChangeValueForKey:通知观察者</li>
<li>当一个property没有观察者时，删除重写的方法</li>
<li>当没有observer观察任何一个property时，删除动态创建的子类</li>
</ol>
<p>因此，要想KVO生效，必须直接或间接的通过setter方法访问属性（KVC的setValue就是间接方式）。直接访问成员变量KVO是不生效的。</p>
<p>直接访问成员变量，并希望触发。则通过在赋值前后手动调用这些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><p>KVO是基于KVC实现的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/27/OC之Runtime/" data-id="ck28skzrg000y0cz64vcqfh3i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask系列（-）介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/18/Flask系列（-）介绍/" class="article-date">
  <time datetime="2017-09-18T02:42:42.000Z" itemprop="datePublished">2017-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/18/Flask系列（-）介绍/">Flask系列（-）介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Flask是一个微-micro-框架。"><a href="#Flask是一个微-micro-框架。" class="headerlink" title="Flask是一个微(micro)框架。"></a>Flask是一个微(micro)框架。</h2><p>微框架不是说所有的内容都得写在同一个文件中，也不是说它缺少功能。<br>微框架意味着它定位核心简洁而扩展性强。<br>不会替你去做很多的决定和限制，比如不会去限制你是用什么样的数据库（Sql和NoSql都可以）。<br>不过，它也帮你做了一些决定。比如它决定内置使用jinja2这个模板引擎。个人觉得和他的web框架的定位有关，但是更换模板引擎也是很简单的事情。<br>基本上所有的都取决于你，梦想有多大舞台就有过大！</p>
<h2 id="Flask有许多非常有意义的默认值的配置值，和一些符合理约定。"><a href="#Flask有许多非常有意义的默认值的配置值，和一些符合理约定。" class="headerlink" title="Flask有许多非常有意义的默认值的配置值，和一些符合理约定。"></a>Flask有许多非常有意义的默认值的配置值，和一些符合理约定。</h2><p>比如templates和static文件夹。当然这也是可以改变的，不过通常你不需要这么做，特别是在开始的时候。</p>
<h2 id="Flask的扩展"><a href="#Flask的扩展" class="headerlink" title="Flask的扩展"></a>Flask的扩展</h2><p>当开始使用Flask的时候，你将会发现大量的扩展。Flask的核心团队会review这些扩展，确保这些扩展不会打乱未来的版本更新。Flask包含许多钩子去自定义它的行为。当然你需要更多的自定义的时候，你还可以实现一个Flask的子类。</p>
<h2 id="Flask安装"><a href="#Flask安装" class="headerlink" title="Flask安装"></a>Flask安装</h2><p>Flask有两个依赖库，Werkzeug和Jinja2。前者是一个WSGI的工具集。后者是模板渲染引擎。<br>这里有个趣闻，据说当年Flask的作者开发了Werkzeug推荐给Bottle，不过Bottle的作者无情拒绝~~然后就出现了Flask，一切都是这么的偶然。也有Django的作者感叹，Flask成为了Django希望成为的样子。扯远了，回归主题。  </p>
<p>这里首先推荐使用virtualenv。virtualenv正如它的名字一样，用它可以创建虚拟环境，可以是python3或者python2的。他解决的问题是不同的application可能会依赖不同python版本，不同package版本。在iOS项目中每当Swift版本升级就是直接花一两天升级上去，或者在project或者workspace中设置不同的Swift版本，才可以运行不同的Swift版本项目。至于为什么Python中不是直接升级上去，我想这也是众多python开发者心中的痛吧。</p>
<p>简单的几行命令就可以完成安装，只能说棒棒哒💯</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p python3 venv      /* 1. 安装一个python3的虚拟环境 */</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate        /* 2. 启动虚拟环境 */</span><br><span class="line">pip3 install flask              /* 3. 安装flask */</span><br><span class="line">pip3 freeze &gt; requirement.txt   /* 4. 将所有依赖保存到requirement.txt中 */</span><br><span class="line">deactivate                      /* 5. 关闭虚拟环境 */</span><br></pre></td></tr></table></figure>
<h2 id="Flask-Hello-World"><a href="#Flask-Hello-World" class="headerlink" title="Flask Hello World!"></a>Flask Hello World!</h2><p>所有的语言都是从helloworld开始的，所有RxSwift都是从login开始的，所有的web都是从todomvc开始的。<br>Flask作为一个web框架，我们暂且从hello world开始吧！<br>写一个文件hello.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &apos;Hello, World!&apos;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先我们从flask包中导入Flask类。（这个和js的风格反着，我好难受啊！）</li>
<li>我们用Flask创建一个app实例。传入一个<strong>name</strong>的参数，为什么传入一个<strong>name</strong>因为flask会根据package的名字去寻找他的资源名字templates, statics, instance etc.</li>
<li>函数顶部写入了一个route装饰器。URL指向下面的view function, 内部会自动将函数名作为endpoint，从而建立 url—&gt;endpoint—&gt;view function的映射，我一开始特别不理解为什么要中间转一层，后来发现防止函数重名，blueprint做铺垫等作用</li>
<li>我们定义并实现了一个hello_world的function。这个function的返回值如果是字符串会被后续response类进一步处理</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> FLASK_APP=hello.py</span><br><span class="line">$ flask run</span><br></pre></td></tr></table></figure>
<p>这样在浏览器的localhost:5000就可以看到一个大大的hello, world了！</p>
<h2 id="留个尾巴"><a href="#留个尾巴" class="headerlink" title="留个尾巴"></a>留个尾巴</h2><p>flask的启动流程和route的流程，我们慢慢来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/18/Flask系列（-）介绍/" data-id="ck28skzq200050cz61w3wlra2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask初窥" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/15/Flask初窥/" class="article-date">
  <time datetime="2017-09-15T06:52:05.000Z" itemprop="datePublished">2017-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/15/Flask初窥/">Flask初窥</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>安装Python3<br> 自行google，安装后自带了virtualenv<br> 推荐使用homebrew安装，简单方便</p>
</li>
<li><p>通过virtualenv安装flask</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p python3 venv      /* 1. 安装一个python3的虚拟环境 */</span><br><span class="line"><span class="built_in">source</span> venv/bin/activate        /* 2. 启动虚拟环境 */</span><br><span class="line">pip3 install flask              /* 3. 安装flask */</span><br><span class="line">pip3 freeze &gt; requirement.txt   /* 4. 将所有依赖保存到requirement.txt中 */</span><br><span class="line">deactivate                      /* 5. 关闭虚拟环境 */</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建基本目录<br> yourapplication/<br> |– venv/<br> |– instance/<br> |   |– config.py<br> |– yourapplication/<br> |   |– <code>__init__.py</code><br> |   |– error.py<br> |   |– blueprints/<br> |– requirement.txt<br> |– run.py</p>
</li>
<li><p>使用一个package而不是module<br> 在yourapplication文件中添加<code>__init__.py</code>，使其变成一个package</p>
</li>
<li><p>使用blueprint拆分模块<br> 在yourapplication/blueprints/下，创建一个user folder，其中添加<code>__init__.py</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">bp = Blueprint(&apos;user&apos;, __name__)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用MethodView创建restful的api<br> 还是在<code>user/__init__.py</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from flask import Blueprint</span><br><span class="line">from flask.views import MethodView</span><br><span class="line"></span><br><span class="line">bp = Blueprint(&apos;user&apos;, __name__)</span><br><span class="line"></span><br><span class="line">class User(MethodView):</span><br><span class="line">    def get(self, user_id=None):</span><br><span class="line">        if user_id is None:</span><br><span class="line">            return &quot;hello users!&quot;</span><br><span class="line">        else:</span><br><span class="line">            return &quot;hello&#123;0&#125;&quot;.format(user_id)</span><br><span class="line"></span><br><span class="line">user_view = User.as_view(&apos;user&apos;)</span><br><span class="line">bp.add_url_rule(&apos;/&apos;, view_func=user_view, methods=[&apos;GET&apos;,])</span><br><span class="line">bp.add_url_rule(&apos;/&lt;int:user_id&gt;&apos;, view_func=user_view, methods=[&apos;GET&apos;,])</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用工厂模式创建app<br> 在<code>yourapplication/__init__.py</code>中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">def create_app():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">    from .blueprints.user import bp as user_bp</span><br><span class="line">    app.register_blueprint(user_bp, url_prefix=&apos;/users&apos;)</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure>
</li>
<li><p>在run.py中启动app</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    from yourapplication import create_app</span><br><span class="line">    app = create_app()</span><br><span class="line">    // app会根据instance_relative_config=True自动寻找instance文件夹</span><br><span class="line">    app.config.from_pyfile(&apos;config.py&apos;, silent=True) </span><br><span class="line">    app.run()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在instance文件中创建配置文件config.py<br> <em>这个config.py文件不应该出现在版本控制中，因此应该在.gitignore文件中处理</em><br> <em>在<code>yourapplication/__init__.py</code>中修改Flask创建的实例</em></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__, instance_relative_config=True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义的错误处理<br> 在error.py中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CustomException(Exception):</span><br><span class="line">    def __init__(self, message, code=400):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.message = message</span><br><span class="line">        self.code = code</span><br><span class="line"></span><br><span class="line">    def to_dict(self):</span><br><span class="line">        // 此处暂时没有找到很好的方式遍历对象的属性，勉强先这么干</span><br><span class="line">        return self.__dict__</span><br></pre></td></tr></table></figure>
<p> 在<code>yourapplication/__init__.py</code>的工厂方法中注册</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@app.errorhandler(CustomException)</span><br><span class="line">def handle_custom_exception(error):</span><br><span class="line">    response = jsonify(error.to_dict())</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>
<p> 在视图函数中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from yourapplication.error import CustomException</span><br><span class="line">raise CustomException(&apos;not found&apos;, 404)</span><br><span class="line">raise CustomException(&apos;permission denied&apos;, 403)</span><br></pre></td></tr></table></figure>
</li>
<li><p>CORS处理<br>在<code>yourapplication/__init__.py</code>的工厂方法中注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.after_request</span><br><span class="line">def handle_after_request(response):</span><br><span class="line">    response.headers.add(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)</span><br><span class="line">    response.headers.add(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type,Authorization&apos;)</span><br><span class="line">    response.headers.add(&apos;Access-Control-Allow-Methods&apos;, &apos;GET,PUT,POST,DELETE&apos;)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>
</li>
<li><p>and so on<br>还有会关于flask-sqlalchemy, authentication等相关内容</p>
<p>参考链接</p>
<ul>
<li><a href="http://flask.pocoo.org/docs/0.12/" target="_blank" rel="noopener">Flask Doc</a></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/15/Flask初窥/" data-id="ck28skzq000040cz65v850ftn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue初窥" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/27/Vue初窥/" class="article-date">
  <time datetime="2017-08-27T12:07:07.000Z" itemprop="datePublished">2017-08-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/27/Vue初窥/">Vue初窥</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>安装git和node环境<br> 不是本篇重点自行google</p>
</li>
<li><p>安装全局的vue-cli</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化项目</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack project-name </span><br><span class="line">vue init webpack-simple project-name</span><br><span class="line">//以上两条命令区别在于不同的模板，整理我使用第一个命名</span><br></pre></td></tr></table></figure>
<p> <em>没有绝对的实力，请不要使用eslint</em></p>
</li>
<li><p>进入项目安装依赖包</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> project-name</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用scss配置，更方便的书写css（可嵌套，可定义变量等）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sass-loader node-sass -S</span><br></pre></td></tr></table></figure>
<p> 如果失败了，请使用淘宝源  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm i sass-loader node-sass -S</span><br></pre></td></tr></table></figure>
<p> 然后在webpack.base.conf.js文件中添加配置  </p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.s[a|c]ss$/,</span><br><span class="line">    loader: 'style!css!sass'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装element-ui（强大的UI控件框架，24分栏）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>
<p> 在main.js中</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-default/index.css'</span></span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装axios（Vue推荐的网络请求框架）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios -S</span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">Vue.use(axios)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Vue-Router路由管理，Vuex状态管理<br> 这一步操作，在有的项目初始化模板中已经包含，如何未包含可通过一下指令添加对应的库</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i Vue-Router Vuex -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>参考链接</p>
<ul>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue文档</a></li>
<li><a href="https://router.vuejs.org/zh-cn/" target="_blank" rel="noopener">vue-router文档</a></li>
<li><a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">vuex文档</a></li>
<li><a href="http://element.eleme.io/#/zh-CN/guide/design" target="_blank" rel="noopener">element-ui</a></li>
<li><a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">axios</a></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/27/Vue初窥/" data-id="ck28skzqp000i0cz6fdin7ggr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/18/hello-world/" class="article-date">
  <time datetime="2017-08-18T09:27:32.000Z" itemprop="datePublished">2017-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>你好，我叫周欣，一个在北京北漂的江苏东台人。<br>我是一个iOS、web前端工程师。当我无聊的时候，也喜欢用python写写服务器。<br>喜欢篮球，喜欢电影，喜欢游泳，喜欢做饭。  </p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>备忘和总结那些已经掌握的知识和技能<br>锻炼自己的表达能力，和写作能力<br>督促自己能够定期的学习和进步  </p>
<h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><p><a href="mailto:hustdestiny@gmail.com" target="_blank" rel="noopener">hustdestiny@gmail.com</a><br>Twitter: @hust_destiny  </p>
<hr>
<p>请多指教<br>周欣</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/18/hello-world/" data-id="ck28skzqv000m0cz68f3vinr7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/27/MacBook-Pro-Retina-13-inch-Early-2015-更换ssd/">MacBook Pro(Retina, 13-inch, Early 2015)更换ssd</a>
          </li>
        
          <li>
            <a href="/2019/10/16/iOS证书和推送/">iOS证书和推送</a>
          </li>
        
          <li>
            <a href="/2019/06/06/CocoaPods/">CocoaPods</a>
          </li>
        
          <li>
            <a href="/2019/04/07/函数小计和数据结构/">函数小计和数据结构</a>
          </li>
        
          <li>
            <a href="/2019/03/07/git-handbook/">git handbook</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 hust_destiny<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>